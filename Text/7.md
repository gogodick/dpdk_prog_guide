
# 7. Mbuf库
mbuf库提供了分配和释放buffer（mbuf）的能力，DPDK应用可以使用mbuf保存消息buffer。消息buffer被保存到mempool，使用了[Mempool Library](https://github.com/gogodick/dpdk_prog_guide/blob/master/Text/6.md)。

rte_mbuf结构可以携带网络报文buffer或者通用的控制buffer（标志是CTRL_MBUF_FLAG）。可以扩展成其他类型。rte_mbuf头结构要尽可能的小，现在只使用两个cache行，最常用的字段放在第一个cache行。

## 7.1. 报文缓冲的设计
对于报文数据的存储（包括协议头），考虑了两种方式：

1. 在单个存储buffer结构嵌入metadata，后面是一个固定大小的区域用于报文数据。
2. 为metadata结构和报文数据使用分开的内存buffer。

第一种方式的优势是，只需要一个操作来分配或释放报文的全部内存。另一方面，第二种方式更灵活，分配metadata结构和分配报文数据buffer是完全独立的。

DPDK选择了第一种方法。metadata包括了控制信息，比如消息类型，长度，到数据起始处的偏移，以及指向附加mbuf结构的指针，允许链接buffer。

用于承载网络报文的消息buffer可以支持链接，从而能够提供多个buffer存放完整报文。例如，巨帧（jumbo frame）是通过mbuf的next指针链接多个mbuf构成的。

对于新分配的mbuf，buffer起始位置的RTE_PKTMBUF_HEADROOM字节后是数据区域，这个区域是cache对齐的。消息buffer可以用来在系统的不同实体之间携带控制信息，报文，事件等等。消息buffer也可以用buffer指针指向其他消息buffer的数据区域或者其他结构。

图7.1和图7.2显示了一些场景。

![Fig. 7.1 An mbuf with One Segment](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/mbuf1.svg)

![Fig. 7.2 An mbuf with Three Segments](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/mbuf2.svg)

buffer管理器实现了一套标准的buffer访问函数，用于网络报文的操作。

## 7.2. 内存池保存的buffer
buffer管理器使用[Mempool Library](https://github.com/gogodick/dpdk_prog_guide/blob/master/Text/6.md)来分配buffer。所以保证了L3处理的报文头能够均衡的分布到内存通道和rank。mbuf包含了一个字段，表明分配这个mbuf的内存池。调用rte_ctrlmbuf_free(m)或者rte_pktmbuf_free(m)时，mbuf被使用到原来的内存池。

## 7.3. 构造函数
报文和控制mbuf的构造函数是由API提供的。rte_pktmbuf_init()和rte_ctrlmbuf_init()初始化了mbuf结构的部分成员，这些成员在创建后不会被用户修改（mbuf类型，原来的内存池，buffer起始地址等等）。在创建内存池时，rte_mempool_create()函数把这个构造函数注册为回调函数。

## 7.4. 分配和释放mbuf
分配新的mbuf时，用户需要指定从哪个mempool分配mbuf。任何新分配的mbuf，都包含一个长度为0的段。到数据的偏移被初始化为buffer里一定字节数的头部空间（RTE_PKTMBUF_HEADROOM）。

释放mbuf表示把mbuf归还到原始的mempool。mbuf存放在内存池时（作为空闲mbuf），不修改mbuf的内存。分配mbuf时，不需要重新初始化构造函数初始化的字段。

当释放包含多个段的报文mbuf时，这些mbuf都被释放和归还到原始的mempool。

## 7.5. 操作mbuf
这个库提供了一些函数来操作报文mbuf的数据。例如：

* 获取数据长度
* 获取数据起始位置的指针
* 在数据前部插入数据
* 在数据后部添加数据
* 删除buffer开始处的数据（rte_pktmbuf_adj()）
* 删除buffer结束处的数据（rte_pktmbuf_trim()），可以从DPDK API Reference获取细节。
# 7.6. Meta Information
Some information is retrieved by the network driver and stored in an mbuf to make processing easier. For instance, the VLAN, the RSS hash result (see [Poll Mode Driver](https://github.com/gogodick/dpdk_prog_guide/blob/master/Text/8.md)) and a flag indicating that the checksum was computed by hardware.

An mbuf also contains the input port (where it comes from), and the number of segment mbufs in the chain.

For chained buffers, only the first mbuf of the chain stores this meta information.

For instance, this is the case on RX side for the IEEE1588 packet timestamp mechanism, the VLAN tagging and the IP checksum computation.

On TX side, it is also possible for an application to delegate some processing to the hardware if it supports it. For instance, the PKT_TX_IP_CKSUM flag allows to offload the computation of the IPv4 checksum.

The following examples explain how to configure different TX offloads on a vxlan-encapsulated tcp packet: out_eth/out_ip/out_udp/vxlan/in_eth/in_ip/in_tcp/payload

* calculate checksum of out_ip:

```
mb->l2_len = len(out_eth)
mb->l3_len = len(out_ip)
mb->ol_flags |= PKT_TX_IPV4 | PKT_TX_IP_CSUM
set out_ip checksum to 0 in the packet
```
This is supported on hardware advertising DEV_TX_OFFLOAD_IPV4_CKSUM.

* calculate checksum of out_ip and out_udp:

```
mb->l2_len = len(out_eth)
mb->l3_len = len(out_ip)
mb->ol_flags |= PKT_TX_IPV4 | PKT_TX_IP_CSUM | PKT_TX_UDP_CKSUM
set out_ip checksum to 0 in the packet
set out_udp checksum to pseudo header using rte_ipv4_phdr_cksum()
```
This is supported on hardware advertising DEV_TX_OFFLOAD_IPV4_CKSUM and DEV_TX_OFFLOAD_UDP_CKSUM.

* calculate checksum of in_ip:

```
mb->l2_len = len(out_eth + out_ip + out_udp + vxlan + in_eth)
mb->l3_len = len(in_ip)
mb->ol_flags |= PKT_TX_IPV4 | PKT_TX_IP_CSUM
set in_ip checksum to 0 in the packet
```
This is similar to case 1), but l2_len is different. It is supported on hardware advertising DEV_TX_OFFLOAD_IPV4_CKSUM. Note that it can only work if outer L4 checksum is 0.

* calculate checksum of in_ip and in_tcp:

```
mb->l2_len = len(out_eth + out_ip + out_udp + vxlan + in_eth)
mb->l3_len = len(in_ip)
mb->ol_flags |= PKT_TX_IPV4 | PKT_TX_IP_CSUM | PKT_TX_TCP_CKSUM
set in_ip checksum to 0 in the packet
set in_tcp checksum to pseudo header using rte_ipv4_phdr_cksum()
```
This is similar to case 2), but l2_len is different. It is supported on hardware advertising DEV_TX_OFFLOAD_IPV4_CKSUM and DEV_TX_OFFLOAD_TCP_CKSUM. Note that it can only work if outer L4 checksum is 0.

* segment inner TCP:

```
mb->l2_len = len(out_eth + out_ip + out_udp + vxlan + in_eth)
mb->l3_len = len(in_ip)
mb->l4_len = len(in_tcp)
mb->ol_flags |= PKT_TX_IPV4 | PKT_TX_IP_CKSUM | PKT_TX_TCP_CKSUM |
  PKT_TX_TCP_SEG;
set in_ip checksum to 0 in the packet
set in_tcp checksum to pseudo header without including the IP
  payload length using rte_ipv4_phdr_cksum()
```
This is supported on hardware advertising DEV_TX_OFFLOAD_TCP_TSO. Note that it can only work if outer L4 checksum is 0.

* calculate checksum of out_ip, in_ip, in_tcp:

```
mb->outer_l2_len = len(out_eth)
mb->outer_l3_len = len(out_ip)
mb->l2_len = len(out_udp + vxlan + in_eth)
mb->l3_len = len(in_ip)
mb->ol_flags |= PKT_TX_OUTER_IPV4 | PKT_TX_OUTER_IP_CKSUM  | \
  PKT_TX_IP_CKSUM |  PKT_TX_TCP_CKSUM;
set out_ip checksum to 0 in the packet
set in_ip checksum to 0 in the packet
set in_tcp checksum to pseudo header using rte_ipv4_phdr_cksum()
```
This is supported on hardware advertising DEV_TX_OFFLOAD_IPV4_CKSUM, DEV_TX_OFFLOAD_UDP_CKSUM and DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM.

The list of flags and their precise meaning is described in the mbuf API documentation (rte_mbuf.h). Also refer to the testpmd source code (specifically the csumonly.c file) for details.

## 7.7. Direct and Indirect Buffers
A direct buffer is a buffer that is completely separate and self-contained. An indirect buffer behaves like a direct buffer but for the fact that the buffer pointer and data offset in it refer to data in another direct buffer. This is useful in situations where packets need to be duplicated or fragmented, since indirect buffers provide the means to reuse the same packet data across multiple buffers.

A buffer becomes indirect when it is “attached” to a direct buffer using the rte_pktmbuf_attach() function. Each buffer has a reference counter field and whenever an indirect buffer is attached to the direct buffer, the reference counter on the direct buffer is incremented. Similarly, whenever the indirect buffer is detached, the reference counter on the direct buffer is decremented. If the resulting reference counter is equal to 0, the direct buffer is freed since it is no longer in use.

There are a few things to remember when dealing with indirect buffers. First of all, an indirect buffer is never attached to another indirect buffer. Attempting to attach buffer A to indirect buffer B that is attached to C, makes rte_pktmbuf_attach() automatically attach A to C, effectively cloning B. Secondly, for a buffer to become indirect, its reference counter must be equal to 1, that is, it must not be already referenced by another indirect buffer. Finally, it is not possible to reattach an indirect buffer to the direct buffer (unless it is detached first).

While the attach/detach operations can be invoked directly using the recommended rte_pktmbuf_attach() and rte_pktmbuf_detach() functions, it is suggested to use the higher-level rte_pktmbuf_clone() function, which takes care of the correct initialization of an indirect buffer and can clone buffers with multiple segments.

Since indirect buffers are not supposed to actually hold any data, the memory pool for indirect buffers should be configured to indicate the reduced memory consumption. Examples of the initialization of a memory pool for indirect buffers (as well as use case examples for indirect buffers) can be found in several of the sample applications, for example, the IPv4 Multicast sample application.

## 7.8. Debug
In debug mode (CONFIG_RTE_MBUF_DEBUG is enabled), the functions of the mbuf library perform sanity checks before any operation (such as, buffer corruption, bad type, and so on).

## 7.9. Use Cases
All networking application should use mbufs to transport network packets.
