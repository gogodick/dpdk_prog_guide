# 11. 流量管理API
## 11.1. 概述
这是以太网设备的服务质量（QoS）流量管理的通用API，支持的主要功能有：分层调度，流量整形，拥塞管理，报文着色。这个API不涉及硬件实现，软件实现或者软硬件结合的实现。

主要功能：

* 是DPDK的rte_ethdev的API的一部分
* 每个端口，每个分层级别和每个分层节点的能力查询API
* 调度算法：严格优先级（SP），加权公平队列（WFQ）
* 流量整形：单速率和双速率，每个节点私有的整形器和多个节点共享的整形器
* 分层叶子节点的拥塞管理：尾部丢弃，头部丢弃，加权随机早期丢弃（WRED），每个节点私有的WRED上下文和多个节点共享的WRED上下文
* 报文着色：IEEE 802.1q（VLAN DEI），IETF RFC 3168（IPv4/IPv6 ECN for TCP and SCTP），IETF RFC 2597（IPv4/IPv6 DSCP）
## 11.2. 能力API
这些API的目标是为应用提供TM实现（硬件或软件）的能力信息（例如关键参数的值）。这些API支持TM级别的能力，TM的任何分层级别的能力，特定分层级别的任何节点级别的能力。这些信息帮助用户快速了解特定实现是否能够满足用户应用的需求。

在TM级别上，节点的数量，分层级别的数量，整形器的数量，私有整形器的数量，调度算法的类型（严格优先级，加权公平队列等等），这些参数由具体实现决定，帮助用户得到高层次的理解。

同样，用户可以查询分层级别的能力，获取这个级别更具体的信息。分层级别的能力查询的结果包括，这个级别的节点数量，这个级别的叶子节点和非叶子节点的数量，如果是非叶子节点对应整形器的类型（单速率，双速率）。

最后，节点级别的能力API提供了任何级别的节点支持的能力。API提供了，是否支持私有整形器，双速率整形器，整形器的最大值和最小值，等等。

## 11.3. 调度算法
基本的调度算法是严格优先级（SP）和加权公平队列（WFQ）。在调度分层的每个节点级别支持SP和WFQ算法，无论节点在树的级别和位置。SP算法用来调度优先级不同的兄弟节点，而WFQ用来调度优先级相同的兄弟组。

其他算法如负载均衡算法（WRR），字节级别的WRR，赤字WRR（DWRR）等等，和典型的WFQ类似，所以用WFQ代替这些算法，尽管精确度，性能和使用的资源可能不同。

## 11.4. 流量整形
TM的API对分层节点支持单速率整形器和双速率整形器（限速器），由具体实现的支持决定。

每个分层节点有0个或者1个私有整形器（只有一个节点使用），还有0个，1个或者多个共享整形器（多个节点使用同一个整形器）。私有整形器用于一个节点的流量整形，共享整形器用于一组节点的流量整形。

通过整形器profile配置私有整形器和共享整形器。任何整形器profile（单速率整形器和双速率整形器）可以用于一个或多个整形器实例（私有或共享）。

单速率整形器使用一个令牌桶。所以，单速率整形器把committed桶设为0，关闭这个桶。而peak桶用来限制单速率整形器的速率和突发大小。双速率整形器使用了committed令牌桶和peak令牌桶。peak桶的速率必须大于0，并且大于等于committed桶的速率。

## 11.5. 拥塞管理
拥塞管理用来在发生拥塞时控制报文进入一个队列或者一组队列。支持的拥塞管理算法有：尾部丢弃，头部丢弃和加权随机早期检测（WRED）。分层的每个叶子节点都可以使用，受具体实现限制。在队列满时，一个新的报文请求入队列，尾部丢弃算法丢掉新报文，不修改队列，而头部丢弃算法丢掉队列头部的报文（队列中等待时间最长的报文），允许新报文进入队列尾部。

随机早期检测（RED）算法的工作方式，在队列积累过程中主动丢弃一个和多个报文。当队列满或者接近满时，RED和尾部丢弃一样。加权RED（WRED）对每种报文颜色使用独立的RED阈值

每个使用WRED作为拥塞管理模式的分层叶子节点，有0个或1个私有WRED上下文（只有一个叶子节点使用），有0个，1个或者多个共享的WRED上下文（多个叶子节点使用相同的WRED上下文）。私有的WRED上下文用于一个叶子节点的拥塞管理，而共享的WRED上下文用于一组叶子节点的拥塞管理。

私有和共享WRED上下文的配置是通过WRED profile实现的。任何WRED profile可以用于一个或多个WRED上下文（私有或共享的）。

## 11.6. 报文着色
TM的API支持多种报文着色，例如VLAN DEI报文着色（IEEE 802.1Q），IPv4/IPv6的TCP和SCTP报文的ECN着色（IETF RFC 3168）以及IPv4/IPv6的DSCP报文着色（IETF RFC 2597）。如果打开了一种颜色的着色，对应的全部VLAN报文都会设置DEI位。如果没有打开着色，不修改DEI位（无论之前设置没有）。

如果当前颜色打开了着色功能，对应的IPv4/IPv6的TCP和SCTP报文把ECN设为2’b11，否则不修改ECN。

所有IPv4/IPv6报文使用DSCP的第3位和第4位表示颜色：绿色表示低丢弃优先级（2’b01），黄色表示中丢弃优先级（2’b10）而红色表示高丢弃优先级（2’b11）。每种颜色需要设置开关；一种颜色没有打开着色时，颜色对应的报文的DSCP不作修改。

## 11.7. 设置分层的步骤
TM分层树包括叶子节点和非叶子节点。每个叶子节点对应当前以太网端口的一个调度队列。所以，叶子节点
The TM hierarchical tree consists of leaf nodes and non-leaf nodes. Each leaf node sits on top of a scheduling queue of the current Ethernet port. Therefore, the leaf nodes have predefined IDs in the range of 0... (N-1), where N is the number of scheduling queues of the current Ethernet port. The non-leaf nodes have their IDs generated by the application outside of the above range, which is reserved for leaf nodes.

Each non-leaf node has multiple inputs (its children nodes) and single output (which is input to its parent node). It arbitrates its inputs using Strict Priority (SP) and Weighted Fair Queuing (WFQ) algorithms to schedule input packets to its output while observing its shaping (rate limiting) constraints.

The children nodes with different priorities are scheduled using the SP algorithm based on their priority, with 0 as the highest priority. Children with the same priority are scheduled using the WFQ algorithm according to their weights. The WFQ weight of a given child node is relative to the sum of the weights of all its sibling nodes that have the same priority, with 1 as the lowest weight. For each SP priority, the WFQ weight mode can be set as either byte-based or packet-based.

### 11.7.1. Initial Hierarchy Specification
The hierarchy is specified by incrementally adding nodes to build up the scheduling tree. The first node that is added to the hierarchy becomes the root node and all the nodes that are subsequently added have to be added as descendants of the root node. The parent of the root node has to be specified as RTE_TM_NODE_ID_NULL and there can only be one node with this parent ID (i.e. the root node). The unique ID that is assigned to each node when the node is created is further used to update the node configuration or to connect children nodes to it.

During this phase, some limited checks on the hierarchy specification can be conducted, usually limited in scope to the current node, its parent node and its sibling nodes. At this time, since the hierarchy is not fully defined, there is typically no real action performed by the underlying implementation.

### 11.7.2. Hierarchy Commit
The hierarchy commit API is called during the port initialization phase (before the Ethernet port is started) to freeze the start-up hierarchy. This function typically performs the following steps:

* It validates the start-up hierarchy that was previously defined for the current port through successive node add API invocations.
* Assuming successful validation, it performs all the necessary implementation specific operations to install the specified hierarchy on the current port, with immediate effect once the port is started.
This function fails when the currently configured hierarchy is not supported by the Ethernet port, in which case the user can abort or try out another hierarchy configuration (e.g. a hierarchy with less leaf nodes), which can be built from scratch or by modifying the existing hierarchy configuration. Note that this function can still fail due to other causes (e.g. not enough memory available in the system, etc.), even though the specified hierarchy is supported in principle by the current port.

### 11.7.3. Run-Time Hierarchy Updates
The TM API provides support for on-the-fly changes to the scheduling hierarchy, thus operations such as node add/delete, node suspend/resume, parent node update, etc., can be invoked after the Ethernet port has been started, subject to the specific implementation supporting them. The set of dynamic updates supported by the implementation is advertised through the port capability set.
