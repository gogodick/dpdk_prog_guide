
# 9. 通用流API (rte_flow)
## 9.1. 概述
这个API提供了一种通用的方法，用来配置硬件规则匹配指定的入方向traffic或者出方向traffic，根据用户定义的规则修改traffic的操作和查询对应的计数器。

所有符号都使用rte_flow作为前缀，定义在rte_flow.h。

* 可以基于报文数据（协议头，载荷）匹配，可以基于报文属性（关联的物理端口，虚拟设备功能ID）匹配。
* 可能的操作包括丢弃traffic，转移指定队列，到VF或者PF或者端口，执行隧道解封装，添加标记等等。

它比传统的过滤框架层次更高，包含和超越了（包括了全部功能和过滤类型）传统的过滤框架，以清楚的方式向所有轮询模式驱动（PMD）提供了统一的接口。

在API迁移章节描述了多种方式，把已有的应用改成新的API。

## 9.2. 流规则
### 9.2.1. 描述
一条流规则是匹配模式和动作列表组成的。流规则是这个API的基础。

流规则可以包括几种不同的动作（把报文发向特定队列之前计数，封装，解封装等等），而不是用几条规则实现这个功能，应用不需要了解硬件的实现细节。

支持规则使用不同的优先级，比如报文匹配两条规则，强制先执行特定规则。但是，不能保证硬件支持多个优先级。即使支持，优先级的数量一般比较少，所以可以在PMD通过软件实现优先级（例如，缺乏优先级时，可以通过规则排序来模拟优先级）。

为了尽可能保持硬件无关，缺省情况下所有规则的优先级是相同的，意味着重叠规则（报文命中多条规则）的顺序是未定义的。

PMD可以拒绝在特定优先级上创建重叠规则（例如，匹配了已有的规则）。

当特定优先级上没有重叠规则，在所有协议层上使用完美匹配，结果才是可预测的。

流规则也可以分组，流规则的优先级由所属的组指定。这样一个组里的全部流规则在另一组之前或之后处理。

可以基于非缺省硬件优先级在内部实现一条规则支持多个动作，结果是应用可能不能同时使用这两个功能。

考虑到无法预先知道允许的匹配模式和动作，而且需要对外提供数量过于庞大的能力，提供了一种方法，根据当前设备配置状态验证规则。

允许应用在初始化时检查是否支持需要的规则类型，不用等到进入数据路径。任何时候都可以使用这种方法，唯一的限制是必须保证规则需要的资源（例如，必须先配置目的RX队列）。

每个定义的规则都和PMD管理的句柄关联，应用负责保存句柄。这些句柄可以用来查询和管理规则，比如获取计数器或其他数据，以及删除规则。

为了避免在PMD泄露资源，应用必须在释放队列和端口这些相关资源之前删除句柄。

以下章节包括：

* 属性（表示为struct rte_flow_attr）：比如流规则的方向（入方向和出方向）和优先级。
* 模式条目（表示为struct rte_flow_item）：匹配模式的一部分，匹配报文数据或者traffic属性。也可以描述模式本身的属性，比如逆向匹配。
* 匹配模式：用于查找的traffic属性，任意条目的组合。
* 动作（表示为struct rte_flow_action）：报文匹配到模式时执行的操作。
### 9.2.2. 属性
#### 9.2.2.1. 属性：组
可以对流规则分组，为规则指定相同的组号。组号的值越小，优先级越高。组0的优先级最高。

尽管是可选的，还是鼓励应用尽可能对类似的规则分组，这样可以充分发挥硬件能力（比如优化匹配）的优势，以及避免限制（比如一个组可能只允许一种模式类型）。

注意不保证支持多个组。

#### 9.2.2.2. 属性：优先级
流规则可以指定优先级。和组一样，优先级的值越小，优先级越高，0是最高优先级。

组8的优先级为0的规则总是在组0的优先级为8的规则之后匹配。

组和优先级是任意的，由应用决定，不需要是连续或者从0开始，但是最大值对于不同设备不一样，并且可能被现有的流规则影响。

如果一个报文匹配了一个组的多条同样优先级的规则，结果是未定义的。可以使用任何路径，可能被复制甚至出现不可修复的错误。

注意不保证支持多个优先级。

#### 9.2.2.3. 属性：traffic方向
流规则可以用于入方向的traffic和出方向的traffic。

多个模式条目和动作是有效的，可以用于两个方向。必须至少指定一个方向。

不推荐为一条规则指定两个方向，但是有些情况（例如，共享计数器）可能需要。

### 9.2.3. 模式条目
模式条目分为两个类别：

* 匹配协议头和报文数据（ANY，RAW，ETH，VLAN，IPV4，IPV6，ICMP，UDP，TCP，SCTP，VXLAN，MPLS，GRE，ESP等等），通常和特定结构关联。
* 匹配meta-data或者有关的模式处理（END，VOID，INVERT，PF，VF，PORT等等），一般没有特定结构。

条目特定结构用来匹配协议字段（或者条目属性）的特定值。文档描述了每个条目是否有特定结构及对应的类型名字。

一个条目最多可以设置3个同类型的结构：

* spec：匹配的值（例如指定IPv4地址）。
* last：spec的对应字段的上限。
* mask：spec和last的位掩码，目的是识别重要的值和部分屏蔽掉（例如，为了匹配IPv4地址前缀）。

用法限制和期望行为：

* 设置mask或者last但是不设置spec是错误配置
* last的字段值是0或者等于spec的对应值会被忽略掉；不能构成范围。字段值不是0而且小于spec的对应值不支持。
* 设置spec和可选的last，但是不设置mask，PMD会使用为条目定义的缺省mask（定义为rte_flow_item_{name}_mask常量）。
* 不设置任何一个（假定条目可以支持），等价于提供了对宽（不指定）匹配使用空（为0）掩码。
* mask是简单的位掩码，先使用掩码，再比较spec和last的内容，如果没有小心使用，可能出现意想不到的结果。例如，对于IPv4地址字段，spec是10.1.2.3，last是10.3.4.5，而mask是255.255.0.0，有效范围是10.1.0.0和10.3.255.255.

匹配以太网头的条目范例：

Table 9.1 Ethernet item
<table>
   <tr>
      <td>字段</td>
      <td>子字段</td>
      <td>值</td>
   </tr>
   <tr>
      <td rowspan="3">spec</td>
      <td>src</td>
      <td>00:01:02:03:04</td>
   </tr>
   <tr>
      <td>dst</td>
      <td>00:2a:66:00:01</td>
   </tr>
   <tr>
      <td>type</td>
      <td>0x22aa</td>
   </tr>
   <tr>
      <td>last</td>
      <td>未定义</td>
      <td></td>
   </tr>
   <tr>
      <td rowspan="3">mask</td>
      <td>src</td>
      <td>00:ff:ff:ff:00</td>
   </tr>
   <tr>
      <td>dst</td>
      <td>00:00:00:00:ff</td>
   </tr>
   <tr>
      <td>type</td>
      <td>0x0000</td>
   </tr>
</table>

非掩码的位表示任意值（下面显示为0），使用以下属性的以太网头会被匹配到：

* src: ??:01:02:03:??
* dst: ??:??:??:??:01
* type: 0x????
### 9.2.4. 匹配模式
模式的结构是从最低层协议开始堆叠匹配的条目。对于meta条目没有这个限制，可以放在任何位置，不影响匹配结果。

模式的结尾是END条目。

例子：

Table 9.2 TCPv4 as L4

|索引|条目|
|:----|:----|
|0	|Ethernet|
|1	|IPv4|
|2	|TCP|
|3	|END|

Table 9.3 TCPv6 in VXLAN

|索引|条目|
|:----|:----|
|0	|Ethernet|
|1	|IPv4|
|2	|UDP|
|3	|VXLAN|
|4	|Ethernet|
|5	|IPv6|
|6	|TCP|
|7	|END|

Table 9.4 TCPv4 as L4 with meta items

|索引|条目|
|:----|:----|
|0	|VOID|
|1	|Ethernet|
|2	|VOID|
|3	|IPv4|
|4	|TCP|
|5	|VOID|
|6	|VOID|
|7	|END|

上面的例子说明meta条目不影响报文数据匹配条目，只要保证堆叠是正确的。模式匹配的结果和“TCPv4 as L4”是一致的。

Table 9.5 UDPv6 anywhere

|索引|条目|
|:----|:----|
|0	|IPv6|
|1	|UDP|
|2	|END|

如果PMD支持，像上面例子（缺少以太网协议层）中省略了底部的一个或多个协议层，会查找报文中的任意位置。

支持的封装类型的载荷（例如VXLAN载荷）是否会匹配这种模式是没有定义的，可能会匹配内层，外层或者两层报文。

Table 9.6 Invalid, missing L3

|索引|条目|
|:----|:----|
|0	|Ethernet|
|1	|UDP|
|2	|END|

上面的模式是无效的，因为缺少L2（以太网）和L4（UDP）之间的L3协议层。只允许缺少底部和顶部的协议层。

### 9.2.5. meta条目类型
meta条目用来匹配meta数据，或者影响模式匹配，而不是直接匹配报文数据，大部分meta条目不需要特定结构。可以在栈的任何位置使用，没有副作用。

#### 9.2.5.1. 条目：END
条目列表的结束标记。阻止继续处理条目，从而结束模式。

* 为了简便，值是0。
* PMD的支持是强制的。
* 忽略spec，last和mask。

Table 9.7 END

|字段|值|
|:----|:----|
|spec	|忽略|
|last	|忽略|
|mask	|忽略|
#### 9.2.5.2. 条目：VOID
作为占位符使用，为了使用方便。PMD忽略和丢弃这个条目。

* PMD的支持是强制的。
* 忽略spec，last和mask。

Table 9.8 VOID

|字段|值|
|:----|:----|
|spec	|忽略|
|last	|忽略|
|mask	|忽略|

这个类型的一个使用范例是，生成使用同样前缀的规则，不需要重新分配内存，只要更新条目类型：

Table 9.9 TCP, UDP or ICMP as L4

<table>
   <tr>
      <td>索引</td>
      <td colspan="3">条目</td>
   </tr>
   <tr>
      <td>0</td>
      <td colspan="3">Ethernet</td>
   </tr>
   <tr>
      <td>1</td>
      <td colspan="3">IPv4</td>
   </tr>
   <tr>
      <td>2</td>
      <td>UDP</td>
      <td>VOID</td>
      <td>VOID</td>
   </tr>
   <tr>
      <td>3</td>
      <td>VOID</td>
      <td>TCP</td>
      <td>VOID</td>
   </tr>
   <tr>
      <td>4</td>
      <td>VOID</td>
      <td>VOID</td>
      <td>ICMP</td>
   </tr>
   <tr>
      <td>5</td>
      <td colspan="3">END</td>
   </tr>
</table>

#### 9.2.5.3. 条目：INVERT
逆向匹配，也就是处理不匹配模式的报文。

* 忽略spec，last和mask。

Table 9.10 INVERT

|字段|值|
|:----|:----|
|spec	|ignored|
|last	|ignored|
|mask	|ignored|

用法示例，匹配非TCPv4的报文：

Table 9.11 Anything but TCPv4

|字段|值|
|:----|:----|
|0	|INVERT|
|1	|Ethernet|
|2	|IPv4|
|3	|TCP|
|4	|END|
#### 9.2.5.4. 条目：PF
匹配定位到设备PF的报文。

如果条目指定的PF和接收traffic的PF不一致，指定这个条目会阻止traffic到达设备，除非流规则设置动作：PF。缺省情况下，报文不会复制到不同设备实例。

* 如果在VF设备使用，可能返回错误，或者无法匹配任何traffic。
* 可以和任意数量的条目混合：VF匹配PF和VF的traffic。
* 不允许设置spec，last和mask。

Table 9.12 PF

|字段|值|
|:----|:----|
|spec	|unset|
|last	|unset|
|mask	|unset|
#### 9.2.5.5. 条目：VF
匹配定位到设备VF的报文。

如果条目指定的VF和接收traffic的VF不一致，指定这个条目会阻止traffic到达设备，除非流规则设置动作：VF。缺省情况下，报文不会复制到不同设备实例。

* 如果在一个VF设备上匹配定位到其他VF的traffic，可能返回错误或者无法匹配任何traffic。
* 可以设置多次，匹配定位到多个VF ID的traffic。
* 可以和PF条目混合，匹配PF和VF的traffic。
* 缺省mask匹配任何VF ID。

Table 9.13 VF

|字段|子字段|值|
|:----|:----|:----|
|spec	|id|目的VF ID|
|last	|id|范围上限值|
|mask	|id|0匹配任何VF ID|
#### 9.2.5.6. 条目：端口
匹配来自底层设备指定端口的报文。

第一个端口条目覆盖了物理端口，通常关联指定的DPDK输入端口（port_id）。可以多次重复这个条目，匹配额外的物理端口。

注意物理端口不一定要和DPDK输入端口（port_id）绑定，他们可能不属于DPDK管理。每个设备可能使用不同的值，值不一定从0开始，可能不连续。

作为设备属性，允许的值的列表以及port_id关联的值应该通过其他方式获取。

* 缺省mask匹配任何端口

Table 9.14 PORT

|字段|子字段|值|
|:----|:----|:----|
|spec|索引|物理端口号|
|last|索引|范围上限值|
|mask|索引|0匹配任何端口|
### 9.2.6. 数据匹配条目类型
大部分是基本的协议头定义和相关的掩码。它们需要从最底层到最高层的协议层堆叠构成匹配模式。

以下列表不是完整的，未来可能增加新的协议。

#### 9.2.6.1. 条目：ANY
匹配当前层的任何协议，一个ANY可以表示多个协议层。

通常指定为第一个模式条目，用来在报文任意位置查找指定的协议。

* 缺省mask表示任意数量的协议层

Table 9.15 ANY

|字段|子字段|值|
|:----|:----|:----|
|spec	|num	|协议层的数量|
|last	|num	|上限值|
|mask	|num	|0表示任意数量的协议层|

下面的例子用来匹配VXLAN TCP的载荷，不关心外层的L3（IPv4或者IPv6）以及L4（UDP），都被第一个ANY匹配，而内层L3（IPv4或者IPv6）由第二个ANY匹配：

Table 9.16 TCP in VXLAN with wildcards

<table>
   <tr>
      <td>索引</td>
      <td>条目</td>
      <td>字段</td>
      <td>子字段</td>
      <td>值</td>
   </tr>
   <tr>
      <td>0</td>
      <td colspan="4">Ethernet</td>
   </tr>
   <tr>
      <td>1</td>
      <td>ANY</td>
      <td>spec</td>
      <td>num</td>
      <td>2</td>
   </tr>
   <tr>
      <td>2</td>
      <td colspan="4">VXLAN</td>
   </tr>
   <tr>
      <td>3</td>
      <td colspan="4">Ethernet</td>
   </tr>
   <tr>
      <td>4</td>
      <td>ANY</td>
      <td>spec</td>
      <td>num</td>
      <td>1</td>
   </tr>
   <tr>
      <td>5</td>
      <td colspan="4">TCP</td>
   </tr>
   <tr>
      <td>6</td>
      <td colspan="4">END</td>
   </tr>
</table>

#### 9.2.6.2. 条目：RAW
在指定偏移上匹配指定长度的字节串。

offset要么是绝对值（从报文开始位置），要么是和前一次匹配的末尾的相对值，这种情况允许负值。

如果使能了search，offset作为起始位置使用。可以把limit设为非0值，从而限制搜索区域，表示offset之后的最大字节数。

允许匹配0长度的模式，这么做会重置子序列条目的相对offset。

* 这个类型不支持范围（last字段）。
* 缺省mask精确匹配所有字段。

Table 9.17 RAW

<table>
   <tr>
      <td>字段</td>
      <td>子字段</td>
      <td>值</td>
   </tr>
   <tr>
      <td>spec</td>
      <td>relative</td>
      <td>从前一条目开始查找模式</td>
   </tr>
   <tr>
      <td></td>
      <td>search</td>
      <td>从offset开始搜索模式（参考limit）</td>
   </tr>
   <tr>
      <td></td>
      <td>reserved</td>
      <td>预留，必须设为0</td>
   </tr>
   <tr>
      <td></td>
      <td>offset</td>
      <td>模式的绝对偏移或者相对偏移</td>
   </tr>
   <tr>
      <td></td>
      <td>limit</td>
      <td>模式起始位置的搜索区域限制</td>
   </tr>
   <tr>
      <td></td>
      <td>length</td>
      <td>模式长度</td>
   </tr>
   <tr>
      <td></td>
      <td>pattern</td>
      <td>查找的字节串</td>
   </tr>
   <tr>
      <td>last</td>
      <td colspan="2">如果指定，要么全0，要么和spec的值一样</td>
   </tr>
   <tr>
      <td>mask</td>
      <td colspan="2">spec值的位掩码，常见行为</td>
   </tr>
</table>

模式示例，用于查找UDP载荷的不同偏移位置的多条字符串，使用了混合RAW条目：

Table 9.18 UDP payload matching

<table>
   <tr>
      <td>索引</td>
      <td>条目</td>
      <td>字段</td>
      <td>子字段</td>
      <td>值</td>
   </tr>
   <tr>
      <td>0</td>
      <td colspan="4">Ethernet</td>
   </tr>
   <tr>
      <td>1</td>
      <td colspan="4">IPv4</td>
   </tr>
   <tr>
      <td>2</td>
      <td colspan="4">UDP</td>
   </tr>
   <tr>
      <td rowspan="6">3</td>
      <td rowspan="6">RAW</td>
      <td rowspan="6">spec</td>
      <td>relative</td>
      <td>1</td>
   </tr>
   <tr>
      <td>search</td>
      <td>1</td>
   </tr>
   <tr>
      <td>offset</td>
      <td>10</td>
   </tr>
   <tr>
      <td>limit</td>
      <td>0</td>
   </tr>
   <tr>
      <td>length</td>
      <td>3</td>
   </tr>
   <tr>
      <td>pattern</td>
      <td>“foo”</td>
   </tr>
   <tr>
      <td rowspan="6">4</td>
      <td rowspan="6">RAW</td>
      <td rowspan="6">spec</td>
      <td>relative</td>
      <td>1</td>
   </tr>
   <tr>
      <td>search</td>
      <td>0</td>
   </tr>
   <tr>
      <td>offset</td>
      <td>20</td>
   </tr>
   <tr>
      <td>limit</td>
      <td>0</td>
   </tr>
   <tr>
      <td>length</td>
      <td>3</td>
   </tr>
   <tr>
      <td>pattern</td>
      <td>“bar”</td>
   </tr>
   <tr>
      <td rowspan="6">5</td>
      <td rowspan="6">RAW</td>
      <td rowspan="6">spec</td>
      <td>relative</td>
      <td>1</td>
   </tr>
   <tr>
      <td>search</td>
      <td>0</td>
   </tr>
   <tr>
      <td>offset</td>
      <td>-29</td>
   </tr>
   <tr>
      <td>limit</td>
      <td>0</td>
   </tr>
   <tr>
      <td>length</td>
      <td>3</td>
   </tr>
   <tr>
      <td>pattern</td>
      <td>“baz”</td>
   </tr>
   <tr>
      <td>6</td>
      <td colspan="4">END</td>
   </tr>
</table>

等价于：

* 在UDP载荷至少10字节偏移处查找“foo”。
* 在“foo”后面20字节处查找“bar”。
* 在“bar”后面向前29字节处查找“baz”。

这样的报文可以如下表示（不按比例）：

```
0                     >= 10 B           == 20 B
|                  |<--------->|     |<--------->|
|                  |           |     |           |
|-----|------|-----|-----|-----|-----|-----------|-----|------|
| ETH | IPv4 | UDP | ... | baz | foo | ......... | bar | .... |
|-----|------|-----|-----|-----|-----|-----------|-----|------|
                         |                             |
                         |<--------------------------->|
                                     == 29 B
```
注意匹配子序列的模式条目会从“baz”继续，而不是“bar”，因为匹配总是从栈的前一个条目开始。

#### 9.2.6.3. 条目：ETH
匹配以太网头。

* dst：目的MAC。
* src：源MAC。
* type：以太类型。
* 缺省mask只匹配目的地址和源地址。
#### 9.2.6.4. Item: VLAN
匹配802.1Q/ad VLAN标签。

* tpid：标签协议标识。
* tci：标签控制信息。
* 缺省mask只匹配TCI。
#### 9.2.6.5. 条目：IPV4
匹配IPv4头。

注意：IPv4选项由专用模式条目处理。

* hdr：IPv4头定义（rte_ip.h）。
* 缺省mask只匹配目的地址和源地址。
#### 9.2.6.6. 条目：IPV6
匹配IPv6头。

注意：IPv6选项由专用模式条目处理。

* hdr：IPv6头定义（rte_ip.h）。
* 缺省mask只匹配目的地址和源地址。
#### 9.2.6.7. 条目：ICMP
匹配ICMP头。

* hdr: ICMP头定义（rte_icmp.h）。
* 缺省mask只匹配ICMP类型和编码。
#### 9.2.6.8. 条目：UDP
匹配UDP头。

* hdr：UDP头定义（rte_udp.h）。
* 缺省mask只匹配源端口和目的端口。
#### 9.2.6.9. 条目：TCP
匹配TCP头。

* hdr：TCP头定义（rte_tcp.h）。
* 缺省mask只匹配源端口和目的端口。
#### 9.2.6.10. 条目：SCTP
匹配SCTP头。

* hdr：SCTP头定义（rte_sctp.h）。
* 缺省mask只匹配源端口和目的端口。
#### 9.2.6.11. 条目：VXLAN
匹配VXLAN头（RFC 7348）。

* flags：通常是0x08（I flag）。
* rsvd0：预留，通常是0x000000。
* vni：VXLAN网络标识。
* rsvd1：预留，通常是0x00。
* 缺省mask只匹配VNI。
#### 9.2.6.12. 条目：E_TAG
匹配IEEE 802.1BR E-Tag头。

* tpid：标签协议标识（0x893F）
* epcp_edei_in_ecid_b：E-Tag控制信息（E-TCI），E-PCP（3b），E-DEI（1b），入向E-CID base（12b）。
* rsvd_grp_ecid_b：reserved (2b)，GRP (2b)，E-CID base (12b)。
* in_ecid_e：入向E-CID ext。
* ecid_e：E-CID ext。
* 缺省mask同时匹配GRP和E-CID base。
#### 9.2.6.13. 条目：NVGRE
匹配NVGRE头（RFC 7637）。

* c_k_s_rsvd0_ver：checksum（1b），undefined（1b），key bit（1b），sequence number（1b），reserved 0（9b），version（3b），根据RFC7637这个字段必须是0x2000。
* protocol：协议类型（0x6558）。
* tni：虚拟子网ID。
* flow_id：流ID。
* 缺省mask只匹配TNI。
#### 9.2.6.14. 条目：MPLS
匹配MPLS头。

* label_tc_s_ttl：标签，TC，栈底部和TTL。
* 缺省mask只匹配label。
#### 9.2.6.15. 条目：GRE
匹配GRE头。

* c_rsvd0_ver：校验和，预留0和版本号。
* protocol：协议类型。
* 缺省mask只匹配protocol。
#### 9.2.6.16. 条目：FUZZY
Fuzzy模式匹配，比缺省匹配方式快。

用于支持fuzzy匹配的设备。通常fuzzy匹配速度更快，但是代价是准确度。比如，签名匹配只匹配模式的哈希值，但有可能两个不同的模式的哈希值相同。

可以通过threshold配置匹配准确度。驱动可以划分threshold的范围，映射到设备支持的不通准确度。

threshold为0表示精确匹配（没有模糊），而threshold为0xffffffff表示模糊匹配。

Table 9.19 FUZZY

|字段|子字段|值|
|:----|:----|:----|
|spec	|threshold	|0表示精确匹配，0xffffffff表示模糊匹配|
|last	|threshold	|上限值|
|mask	|threshold	|用于“spec”和“last”的位掩码|

方法示例，TCPv4报文的fuzzy匹配：

Table 9.20 Fuzzy matching

|索引|条目|
|:----|:----|
|0	|FUZZY|
|1	|Ethernet|
|2	|IPv4|
|3	|TCP|
|4	|END|
#### 9.2.6.17. Item: GTP, GTPC, GTPU
Matches a GTPv1 header.

Note: GTP, GTPC and GTPU use the same structure. GTPC and GTPU item are defined for a user-friendly API when creating GTP-C and GTP-U flow rules.

* v_pt_rsv_flags: version (3b), protocol type (1b), reserved (1b), extension header flag (1b), sequence number flag (1b), N-PDU number * flag (1b).
* msg_type: message type.
* msg_len: message length.
* teid: tunnel endpoint identifier.
* Default mask matches teid only.
#### 9.2.6.18. Item: ESP
Matches an ESP header.

* hdr: ESP header definition (rte_esp.h).
* Default mask matches SPI only.
### 9.2.7. Actions
Each possible action is represented by a type. Some have associated configuration structures. Several actions combined in a list can be affected to a flow rule. That list is not ordered.

They fall in three categories:

* Terminating actions (such as QUEUE, DROP, RSS, PF, VF) that prevent processing matched packets by subsequent flow rules, unless overridden with PASSTHRU.
* Non-terminating actions (PASSTHRU, DUP) that leave matched packets up for additional processing by subsequent flow rules.
* Other non-terminating meta actions that do not affect the fate of packets (END, VOID, MARK, FLAG, COUNT, SECURITY).

When several actions are combined in a flow rule, they should all have different types (e.g. dropping a packet twice is not possible).

Only the last action of a given type is taken into account. PMDs still perform error checking on the entire list.

Like matching patterns, action lists are terminated by END items.

Note that PASSTHRU is the only action able to override a terminating rule.

Example of action that redirects packets to queue index 10:

Table 9.21 Queue action
Field	Value
index	10
Action lists examples, their order is not significant, applications must consider all actions to be performed simultaneously:

Table 9.22 Count and drop
Index	Action
0	COUNT
1	DROP
2	END

Table 9.23 Mark, count and redirect
Index	Action	Field	Value
0	MARK	mark	0x2a
1	COUNT
2	QUEUE	queue	10
3	END

Table 9.24 Redirect to queue 5
Index	Action	Field	Value
0	DROP
1	QUEUE	queue	5
2	END
In the above example, considering both actions are performed simultaneously, the end result is that only QUEUE has any effect.

Table 9.25 Redirect to queue 3
Index	Action	Field	Value
0	QUEUE	queue	5
1	VOID
2	QUEUE	queue	3
3	END
As previously described, only the last action of a given type found in the list is taken into account. The above example also shows that VOID is ignored.

### 9.2.8. Action types
Common action types are described in this section. Like pattern item types, this list is not exhaustive as new actions will be added in the future.

#### 9.2.8.1. Action: END
End marker for action lists. Prevents further processing of actions, thereby ending the list.

* Its numeric value is 0 for convenience.
* PMD support is mandatory.
* No configurable properties.

Table 9.26 END
Field
no properties
#### 9.2.8.2. Action: VOID
Used as a placeholder for convenience. It is ignored and simply discarded by PMDs.

* PMD support is mandatory.
* No configurable properties.

Table 9.27 VOID
Field
no properties
#### 9.2.8.3. Action: PASSTHRU
Leaves packets up for additional processing by subsequent flow rules. This is the default when a rule does not contain a terminating action, but can be specified to force a rule to become non-terminating.

* No configurable properties.

Table 9.28 PASSTHRU
Field
no properties
Example to copy a packet to a queue and continue processing by subsequent flow rules:

Table 9.29 Copy to queue 8
Index	Action	Field	Value
0	PASSTHRU
1	QUEUE	queue	8
2	END
#### 9.2.8.4. Action: MARK
Attaches an integer value to packets and sets PKT_RX_FDIR and PKT_RX_FDIR_ID mbuf flags.

This value is arbitrary and application-defined. Maximum allowed value depends on the underlying implementation. It is returned in the hash.fdir.hi mbuf field.

Table 9.30 MARK
Field	Value
id	integer value to return with packets
#### 9.2.8.5. Action: FLAG
Flags packets. Similar to Action: MARK without a specific value; only sets the PKT_RX_FDIR mbuf flag.

* No configurable properties.

Table 9.31 FLAG
Field
no properties
#### 9.2.8.6. Action: QUEUE
Assigns packets to a given queue index.

* Terminating by default.

Table 9.32 QUEUE
Field	Value
index	queue index to use
#### 9.2.8.7. Action: DROP
Drop packets.

* No configurable properties.
* Terminating by default.
* PASSTHRU overrides this action if both are specified.

Table 9.33 DROP
Field
no properties
#### 9.2.8.8. Action: COUNT
Enables counters for this rule.

These counters can be retrieved and reset through rte_flow_query(), see struct rte_flow_query_count.

* Counters can be retrieved with rte_flow_query().
* No configurable properties.

Table 9.34 COUNT
Field
no properties
Query structure to retrieve and reset flow rule counters:

Table 9.35 COUNT query
Field	I/O	Value
reset	in	reset counter after query
hits_set	out	hits field is set
bytes_set	out	bytes field is set
hits	out	number of hits for this rule
bytes	out	number of bytes through this rule
#### 9.2.8.9. Action: DUP
Duplicates packets to a given queue index.

This is normally combined with QUEUE, however when used alone, it is actually similar to QUEUE + PASSTHRU.

* Non-terminating by default.

Table 9.36 DUP
Field	Value
index	queue index to duplicate packet to
#### 9.2.8.10. Action: RSS
Similar to QUEUE, except RSS is additionally performed on packets to spread them among several queues according to the provided parameters.

Note: RSS hash result is stored in the hash.rss mbuf field which overlaps hash.fdir.lo. Since Action: MARK sets the hash.fdir.hi field only, both can be requested simultaneously.

* Terminating by default.

Table 9.37 RSS
Field	Value
rss_conf	RSS parameters
num	number of entries in queue[]
queue[]	queue indices to use
#### 9.2.8.11. Action: PF
Redirects packets to the physical function (PF) of the current device.

* No configurable properties.
* Terminating by default.

Table 9.38 PF
Field
no properties
#### 9.2.8.12. Action: VF
Redirects packets to a virtual function (VF) of the current device.

Packets matched by a VF pattern item can be redirected to their original VF ID instead of the specified one. This parameter may not be available and is not guaranteed to work properly if the VF part is matched by a prior flow rule or if packets are not addressed to a VF in the first place.

* Terminating by default.

Table 9.39 VF
Field	Value
original	use original VF ID if possible
vf	VF ID to redirect packets to
#### 9.2.8.13. Action: METER
Applies a stage of metering and policing.

The metering and policing (MTR) object has to be first created using the rte_mtr_create() API function. The ID of the MTR object is specified as action parameter. More than one flow can use the same MTR object through the meter action. The MTR object can be further updated or queried using the rte_mtr* API.

* Non-terminating by default.

Table 9.40 METER
Field	Value
mtr_id	MTR object ID
#### 9.2.8.14. Action: SECURITY
Perform the security action on flows matched by the pattern items according to the configuration of the security session.

This action modifies the payload of matched flows. For INLINE_CRYPTO, the security protocol headers and IV are fully provided by the application as specified in the flow pattern. The payload of matching packets is encrypted on egress, and decrypted and authenticated on ingress. For INLINE_PROTOCOL, the security protocol is fully offloaded to HW, providing full encapsulation and decapsulation of packets in security protocols. The flow pattern specifies both the outer security header fields and the inner packet fields. The security session specified in the action must match the pattern parameters.

The security session specified in the action must be created on the same port as the flow action that is being specified.

The ingress/egress flow attribute should match that specified in the security session if the security session supports the definition of the direction.

Multiple flows can be configured to use the same security session.

* Non-terminating by default.

Table 9.41 SECURITY
Field	Value
security_session	security session to apply
The following is an example of configuring IPsec inline using the INLINE_CRYPTO security session:

The encryption algorithm, keys and salt are part of the opaque rte_security_session. The SA is identified according to the IP and ESP fields in the pattern items.

Table 9.42 IPsec inline crypto flow pattern items.
Index	Item
0	Ethernet
1	IPv4
2	ESP
3	END
Table 9.43 IPsec inline flow actions.
Index	Action
0	SECURITY
1	END
### 9.2.9. Negative types
All specified pattern items (enum rte_flow_item_type) and actions (enum rte_flow_action_type) use positive identifiers.

The negative space is reserved for dynamic types generated by PMDs during run-time. PMDs may encounter them as a result but must not accept negative identifiers they are not aware of.

A method to generate them remains to be defined.

### 9.2.10. Planned types
Pattern item types will be added as new protocols are implemented.

Variable headers support through dedicated pattern items, for example in order to match specific IPv4 options and IPv6 extension headers would be stacked after IPv4/IPv6 items.

Other action types are planned but are not defined yet. These include the ability to alter packet data in several ways, such as performing encapsulation/decapsulation of tunnel headers.

## 9.3. Rules management
A rather simple API with few functions is provided to fully manage flow rules.

Each created flow rule is associated with an opaque, PMD-specific handle pointer. The application is responsible for keeping it until the rule is destroyed.

Flows rules are represented by struct rte_flow objects.

### 9.3.1. Validation
Given that expressing a definite set of device capabilities is not practical, a dedicated function is provided to check if a flow rule is supported and can be created.

int
rte_flow_validate(uint16_t port_id,
                  const struct rte_flow_attr *attr,
                  const struct rte_flow_item pattern[],
                  const struct rte_flow_action actions[],
                  struct rte_flow_error *error);
The flow rule is validated for correctness and whether it could be accepted by the device given sufficient resources. The rule is checked against the current device mode and queue configuration. The flow rule may also optionally be validated against existing flow rules and device resources. This function has no effect on the target device.

The returned value is guaranteed to remain valid only as long as no successful calls to rte_flow_create() or rte_flow_destroy() are made in the meantime and no device parameter affecting flow rules in any way are modified, due to possible collisions or resource limitations (although in such cases EINVAL should not be returned).

Arguments:

* port_id: port identifier of Ethernet device.
* attr: flow rule attributes.
* pattern: pattern specification (list terminated by the END pattern item).
* actions: associated actions (list terminated by the END action).
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

* 0 if flow rule is valid and can be created. A negative errno value otherwise (rte_errno is also set), the following errors are defined.
* -ENOSYS: underlying device does not support this functionality.
* -EINVAL: unknown or invalid rule specification.
* -ENOTSUP: valid but unsupported rule specification (e.g. partial bit-masks are unsupported).
* EEXIST: collision with an existing rule. Only returned if device supports flow rule collision checking and there was a flow rule collision. Not receiving this return code is no guarantee that creating the rule will not fail due to a collision.
* ENOMEM: not enough memory to execute the function, or if the device supports resource validation, resource limitation on the device.
* -EBUSY: action cannot be performed due to busy device resources, may succeed if the affected queues or even the entire port are in a stopped state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop()).
### 9.3.2. Creation
Creating a flow rule is similar to validating one, except the rule is actually created and a handle returned.

struct rte_flow *
rte_flow_create(uint16_t port_id,
                const struct rte_flow_attr *attr,
                const struct rte_flow_item pattern[],
                const struct rte_flow_action *actions[],
                struct rte_flow_error *error);
Arguments:

* port_id: port identifier of Ethernet device.
* attr: flow rule attributes.
* pattern: pattern specification (list terminated by the END pattern item).
* actions: associated actions (list terminated by the END action).
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

A valid handle in case of success, NULL otherwise and rte_errno is set to the positive version of one of the error codes defined for rte_flow_validate().

### 9.3.3. Destruction
Flow rules destruction is not automatic, and a queue or a port should not be released if any are still attached to them. Applications must take care of performing this step before releasing resources.

int
rte_flow_destroy(uint16_t port_id,
                 struct rte_flow *flow,
                 struct rte_flow_error *error);
Failure to destroy a flow rule handle may occur when other flow rules depend on it, and destroying it would result in an inconsistent state.

This function is only guaranteed to succeed if handles are destroyed in reverse order of their creation.

Arguments:

* port_id: port identifier of Ethernet device.
* flow: flow rule handle to destroy.
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

* 0 on success, a negative errno value otherwise and rte_errno is set.
### 9.3.4. Flush
Convenience function to destroy all flow rule handles associated with a port. They are released as with successive calls to rte_flow_destroy().

int
rte_flow_flush(uint16_t port_id,
               struct rte_flow_error *error);
In the unlikely event of failure, handles are still considered destroyed and no longer valid but the port must be assumed to be in an inconsistent state.

Arguments:

* port_id: port identifier of Ethernet device.
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

* 0 on success, a negative errno value otherwise and rte_errno is set.
### 9.3.5. Query
Query an existing flow rule.

This function allows retrieving flow-specific data such as counters. Data is gathered by special actions which must be present in the flow rule definition.

int
rte_flow_query(uint16_t port_id,
               struct rte_flow *flow,
               enum rte_flow_action_type action,
               void *data,
               struct rte_flow_error *error);
Arguments:

* port_id: port identifier of Ethernet device.
* flow: flow rule handle to query.
* action: action type to query.
* data: pointer to storage for the associated query data type.
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

* 0 on success, a negative errno value otherwise and rte_errno is set.
## 9.4. Isolated mode
The general expectation for ingress traffic is that flow rules process it first; the remaining unmatched or pass-through traffic usually ends up in a queue (with or without RSS, locally or in some sub-device instance) depending on the global configuration settings of a port.

While fine from a compatibility standpoint, this approach makes drivers more complex as they have to check for possible side effects outside of this API when creating or destroying flow rules. It results in a more limited set of available rule types due to the way device resources are assigned (e.g. no support for the RSS action even on capable hardware).

Given that nonspecific traffic can be handled by flow rules as well, isolated mode is a means for applications to tell a driver that ingress on the underlying port must be injected from the defined flow rules only; that no default traffic is expected outside those rules.

This has the following benefits:

* Applications get finer-grained control over the kind of traffic they want to receive (no traffic by default).
* More importantly they control at what point nonspecific traffic is handled relative to other flow rules, by adjusting priority levels.
* Drivers can assign more hardware resources to flow rules and expand the set of supported rule types.

Because toggling isolated mode may cause profound changes to the ingress processing path of a driver, it may not be possible to leave it once entered. Likewise, existing flow rules or global configuration settings may prevent a driver from entering isolated mode.

Applications relying on this mode are therefore encouraged to toggle it as soon as possible after device initialization, ideally before the first call to rte_eth_dev_configure() to avoid possible failures due to conflicting settings.

Once effective, the following functionality has no effect on the underlying port and may return errors such as ENOTSUP (“not supported”):

* Toggling promiscuous mode.
* Toggling allmulticast mode.
* Configuring MAC addresses.
* Configuring multicast addresses.
* Configuring VLAN filters.
* Configuring Rx filters through the legacy API (e.g. FDIR).
* Configuring global RSS settings.
```
int
rte_flow_isolate(uint16_t port_id, int set, struct rte_flow_error *error);
```
Arguments:

* port_id: port identifier of Ethernet device.
* set: nonzero to enter isolated mode, attempt to leave it otherwise.
* error: perform verbose error reporting if not NULL. PMDs initialize this structure in case of error only.

Return values:

* 0 on success, a negative errno value otherwise and rte_errno is set.
## 9.5. Verbose error reporting
The defined errno values may not be accurate enough for users or application developers who want to investigate issues related to flow rules management. A dedicated error object is defined for this purpose:

```
enum rte_flow_error_type {
    RTE_FLOW_ERROR_TYPE_NONE, /**< No error. */
    RTE_FLOW_ERROR_TYPE_UNSPECIFIED, /**< Cause unspecified. */
    RTE_FLOW_ERROR_TYPE_HANDLE, /**< Flow rule (handle). */
    RTE_FLOW_ERROR_TYPE_ATTR_GROUP, /**< Group field. */
    RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY, /**< Priority field. */
    RTE_FLOW_ERROR_TYPE_ATTR_INGRESS, /**< Ingress field. */
    RTE_FLOW_ERROR_TYPE_ATTR_EGRESS, /**< Egress field. */
    RTE_FLOW_ERROR_TYPE_ATTR, /**< Attributes structure. */
    RTE_FLOW_ERROR_TYPE_ITEM_NUM, /**< Pattern length. */
    RTE_FLOW_ERROR_TYPE_ITEM, /**< Specific pattern item. */
    RTE_FLOW_ERROR_TYPE_ACTION_NUM, /**< Number of actions. */
    RTE_FLOW_ERROR_TYPE_ACTION, /**< Specific action. */
};

struct rte_flow_error {
    enum rte_flow_error_type type; /**< Cause field and error types. */
    const void *cause; /**< Object responsible for the error. */
    const char *message; /**< Human-readable error message. */
};
```
Error type RTE_FLOW_ERROR_TYPE_NONE stands for no error, in which case remaining fields can be ignored. Other error types describe the type of the object pointed by cause.

If non-NULL, cause points to the object responsible for the error. For a flow rule, this may be a pattern item or an individual action.

If non-NULL, message provides a human-readable error message.

This object is normally allocated by applications and set by PMDs in case of error, the message points to a constant string which does not need to be freed by the application, however its pointer can be considered valid only as long as its associated DPDK port remains configured. Closing the underlying device or unloading the PMD invalidates it.

## 9.6. Helpers
### 9.6.1. Error initializer
```
static inline int
rte_flow_error_set(struct rte_flow_error *error,
                   int code,
                   enum rte_flow_error_type type,
                   const void *cause,
                   const char *message);
This function initializes error (if non-NULL) with the provided parameters and sets rte_errno to code. A negative error code is then returned.
```

## 9.7. Caveats
* DPDK does not keep track of flow rules definitions or flow rule objects automatically. Applications may keep track of the former and must keep track of the latter. PMDs may also do it for internal needs, however this must not be relied on by applications.
* Flow rules are not maintained between successive port initializations. An application exiting without releasing them and restarting must re-create them from scratch.
* API operations are synchronous and blocking (EAGAIN cannot be returned).
* There is no provision for reentrancy/multi-thread safety, although nothing should prevent different devices from being configured at the same time. PMDs may protect their control path functions accordingly.
* Stopping the data path (TX/RX) should not be necessary when managing flow rules. If this cannot be achieved naturally or with workarounds (such as temporarily replacing the burst function pointers), an appropriate error code must be returned (EBUSY).
* PMDs, not applications, are responsible for maintaining flow rules configuration when stopping and restarting a port or performing other actions which may affect them. They can only be destroyed explicitly by applications.

For devices exposing multiple ports sharing global settings affected by flow rules:

* All ports under DPDK control must behave consistently, PMDs are responsible for making sure that existing flow rules on a port are not affected by other ports.
* Ports not under DPDK control (unaffected or handled by other applications) are user’s responsibility. They may affect existing flow rules and cause undefined behavior. PMDs aware of this may prevent flow rules creation altogether in such cases.
## 9.8. PMD interface
The PMD interface is defined in rte_flow_driver.h. It is not subject to API/ABI versioning constraints as it is not exposed to applications and may evolve independently.

It is currently implemented on top of the legacy filtering framework through filter type RTE_ETH_FILTER_GENERIC that accepts the single operation RTE_ETH_FILTER_GET to return PMD-specific rte_flow callbacks wrapped inside struct rte_flow_ops.

This overhead is temporarily necessary in order to keep compatibility with the legacy filtering framework, which should eventually disappear.

* PMD callbacks implement exactly the interface described in Rules management, except for the port ID argument which has already been converted to a pointer to the underlying struct rte_eth_dev.
* Public API functions do not process flow rules definitions at all before calling PMD functions (no basic error checking, no validation whatsoever). They only make sure these callbacks are non-NULL or return the ENOSYS (function not supported) error.

This interface additionally defines the following helper function:

* rte_flow_ops_get(): get generic flow operations structure from a port.

More will be added over time.

## 9.9. Device compatibility
No known implementation supports all the described features.

Unsupported features or combinations are not expected to be fully emulated in software by PMDs for performance reasons. Partially supported features may be completed in software as long as hardware performs most of the work (such as queue redirection and packet recognition).

However PMDs are expected to do their best to satisfy application requests by working around hardware limitations as long as doing so does not affect the behavior of existing flow rules.

The following sections provide a few examples of such cases and describe how PMDs should handle them, they are based on limitations built into the previous APIs.

### 9.9.1. Global bit-masks
Each flow rule comes with its own, per-layer bit-masks, while hardware may support only a single, device-wide bit-mask for a given layer type, so that two IPv4 rules cannot use different bit-masks.

The expected behavior in this case is that PMDs automatically configure global bit-masks according to the needs of the first flow rule created.

Subsequent rules are allowed only if their bit-masks match those, the EEXIST error code should be returned otherwise.

### 9.9.2. Unsupported layer types
Many protocols can be simulated by crafting patterns with the Item: RAW type.

PMDs can rely on this capability to simulate support for protocols with headers not directly recognized by hardware.

### 9.9.3. ANY pattern item
This pattern item stands for anything, which can be difficult to translate to something hardware would understand, particularly if followed by more specific types.

Consider the following pattern:

Table 9.44 Pattern with ANY as L3
Index	Item
0	ETHER
1	ANY	num	1
2	TCP
3	END
Knowing that TCP does not make sense with something other than IPv4 and IPv6 as L3, such a pattern may be translated to two flow rules instead:

Table 9.45 ANY replaced with IPV4
Index	Item
0	ETHER
1	IPV4 (zeroed mask)
2	TCP
3	END

Table 9.46 ANY replaced with IPV6
Index	Item
0	ETHER
1	IPV6 (zeroed mask)
2	TCP
3	END
Note that as soon as a ANY rule covers several layers, this approach may yield a large number of hidden flow rules. It is thus suggested to only support the most common scenarios (anything as L2 and/or L3).

### 9.9.4. Unsupported actions
* When combined with Action: QUEUE, packet counting (Action: COUNT) and tagging (Action: MARK or Action: FLAG) may be implemented in software as long as the target queue is used by a single rule.
* A rule specifying both Action: DUP + Action: QUEUE may be translated to two hidden rules combining Action: QUEUE and Action: PASSTHRU.
* When a single target queue is provided, Action: RSS can also be implemented through Action: QUEUE.
### 9.9.5. Flow rules priority
While it would naturally make sense, flow rules cannot be assumed to be processed by hardware in the same order as their creation for several reasons:

* They may be managed internally as a tree or a hash table instead of a list.
* Removing a flow rule before adding another one can either put the new rule at the end of the list or reuse a freed entry.
* Duplication may occur when packets are matched by several rules.

For overlapping rules (particularly in order to use Action: PASSTHRU) predictable behavior is only guaranteed by using different priority levels.

Priority levels are not necessarily implemented in hardware, or may be severely limited (e.g. a single priority bit).

For these reasons, priority levels may be implemented purely in software by PMDs.

* For devices expecting flow rules to be added in the correct order, PMDs may destroy and re-create existing rules after adding a new one with a higher priority.
* A configurable number of dummy or empty rules can be created at initialization time to save high priority slots for later.
* In order to save priority levels, PMDs may evaluate whether rules are likely to collide and adjust their priority accordingly.
## 9.10. Future evolutions
* A device profile selection function which could be used to force a permanent profile instead of relying on its automatic configuration based on existing flow rules.
* A method to optimize rte_flow rules with specific pattern items and action types generated on the fly by PMDs. DPDK should assign negative numbers to these in order to not collide with the existing types. See Negative types.
* Adding specific egress pattern items and actions as described in Attribute: Traffic direction.
* Optional software fallback when PMDs are unable to handle requested flow rules so applications do not have to implement their own.
## 9.11. API migration
Exhaustive list of deprecated filter types (normally prefixed with RTE_ETH_FILTER_) found in rte_eth_ctrl.h and methods to convert them to rte_flow rules.

### 9.11.1. MACVLAN to ETH → VF, PF
MACVLAN can be translated to a basic Item: ETH flow rule with a terminating Action: VF or Action: PF.

Table 9.47 MACVLAN conversion
Pattern	Actions
0	ETH	spec	any	VF, PF
last	N/A
mask	any
1	END	END
### 9.11.2. ETHERTYPE to ETH → QUEUE, DROP
ETHERTYPE is basically an Item: ETH flow rule with a terminating Action: QUEUE or Action: DROP.

Table 9.48 ETHERTYPE conversion
Pattern	Actions
0	ETH	spec	any	QUEUE, DROP
last	N/A
mask	any
1	END	END
### 9.11.3. FLEXIBLE to RAW → QUEUE
FLEXIBLE can be translated to one Item: RAW pattern with a terminating Action: QUEUE and a defined priority level.

Table 9.49 FLEXIBLE conversion
Pattern	Actions
0	RAW	spec	any	QUEUE
last	N/A
mask	any
1	END	END
### 9.11.4. SYN to TCP → QUEUE
SYN is a Item: TCP rule with only the syn bit enabled and masked, and a terminating Action: QUEUE.

Priority level can be set to simulate the high priority bit.

Table 9.50 SYN conversion
Pattern	Actions
0	ETH	spec	unset	QUEUE
last	unset
mask	unset
1	IPV4	spec	unset	END
mask	unset
mask	unset
2	TCP	spec	syn	1
mask	syn	1
3	END
### 9.11.5. NTUPLE to IPV4, TCP, UDP → QUEUE
NTUPLE is similar to specifying an empty L2, Item: IPV4 as L3 with Item: TCP or Item: UDP as L4 and a terminating Action: QUEUE.

A priority level can be specified as well.

Table 9.51 NTUPLE conversion
Pattern	Actions
0	ETH	spec	unset	QUEUE
last	unset
mask	unset
1	IPV4	spec	any	END
last	unset
mask	any
2	TCP, UDP	spec	any
last	unset
mask	any
3	END
### 9.11.6. TUNNEL to ETH, IPV4, IPV6, VXLAN (or other) → QUEUE
TUNNEL matches common IPv4 and IPv6 L3/L4-based tunnel types.

In the following table, Item: ANY is used to cover the optional L4.

Table 9.52 TUNNEL conversion
Pattern	Actions
0	ETH	spec	any	QUEUE
last	unset
mask	any
1	IPV4, IPV6	spec	any	END
last	unset
mask	any
2	ANY	spec	any
last	unset
mask	num	0
3	VXLAN, GENEVE, TEREDO, NVGRE, GRE, ...	spec	any
last	unset
mask	any
4	END
### 9.11.7. FDIR to most item types → QUEUE, DROP, PASSTHRU
FDIR is more complex than any other type, there are several methods to emulate its functionality. It is summarized for the most part in the table below.

A few features are intentionally not supported:

* The ability to configure the matching input set and masks for the entire device, PMDs should take care of it automatically according to the requested flow rules.

For example if a device supports only one bit-mask per protocol type, source/address IPv4 bit-masks can be made immutable by the first created rule. Subsequent IPv4 or TCPv4 rules can only be created if they are compatible.

Note that only protocol bit-masks affected by existing flow rules are immutable, others can be changed later. They become mutable again after the related flow rules are destroyed.

* Returning four or eight bytes of matched data when using flex bytes filtering. Although a specific action could implement it, it conflicts with the much more useful 32 bits tagging on devices that support it.

* Side effects on RSS processing of the entire device. Flow rules that conflict with the current device configuration should not be allowed. Similarly, device configuration should not be allowed when it affects existing flow rules.

* Device modes of operation. “none” is unsupported since filtering cannot be disabled as long as a flow rule is present.

* “MAC VLAN” or “tunnel” perfect matching modes should be automatically set according to the created flow rules.

* Signature mode of operation is not defined but could be handled through “FUZZY” item.

Table 9.53 FDIR conversion
Pattern	Actions
0	ETH, RAW	spec	any	QUEUE, DROP, PASSTHRU
last	N/A
mask	any
1	IPV4, IPv6	spec	any	MARK
last	N/A
mask	any
2	TCP, UDP, SCTP	spec	any	END
last	N/A
mask	any
3	VF, PF, FUZZY (optional)	spec	any
last	N/A
mask	any
4	END
### 9.11.8. HASH
There is no counterpart to this filter type because it translates to a global device setting instead of a pattern item. Device settings are automatically set according to the created flow rules.

### 9.11.9. L2_TUNNEL to VOID → VXLAN (or others)
All packets are matched. This type alters incoming packets to encapsulate them in a chosen tunnel type, optionally redirect them to a VF as well.

The destination pool for tag based forwarding can be emulated with other flow rules using Action: DUP.

Table 9.54 L2_TUNNEL conversion
Pattern	Actions
0	VOID	spec	N/A	VXLAN, GENEVE, ...
last	N/A
mask	N/A
1	END	VF (optional)
2	END
