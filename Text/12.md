# 12. 加密设备库
加密设备库提供了一个加密设备框架，用于管理和配置硬件和软件的加密轮询模式驱动，定义了通用API，支持多种不同的加密操作。现在这个框架只加密，认证，链式加密认证和AEAD对称加密操作。

## 12.1. 设计原则
加密设备库和DPDK以太网设备框架遵循同样的基本原则。加密框架提供了通用的加密设备框架，支持物理（硬件）和虚拟（软件）加密设备，提供了通用的加密API，允许管理和配置加密设备，支持在加密轮询模式驱动上配置加密操作。

## 12.2. 设备管理
### 12.2.1. 设备创建
在DPDK初始化时，执行EAL的PCI枚举功能，基于PCI设备标识，唯一的PCI BDF（总线/桥，设备，功能），发现物理加密设备。和DPDK的其它物理设备一样，可以通过EAL命令行使用白名单和黑名单指定物理加密设备。

创建虚拟设备有两种机制，使用EAL命令行或者在应用中直接使用EAL API。

在命令行使用EAL选项-vdev
```
--vdev  'crypto_aesni_mb0,max_nb_queue_pairs=2,max_nb_sessions=1024,socket_id=0'
```
在应用代码使用rte_vdev_init的API。
```
rte_vdev_init("crypto_aesni_mb",
                  "max_nb_queue_pairs=2,max_nb_sessions=1024,socket_id=0")
```
所有虚拟加密设备都支持以下的初始化参数：

* max_nb_queue_pairs - 设备支持的最大队列对数量。
* max_nb_sessions - 设备支持的最大会话数量。
* socket_id - 分配设备资源的socket。
### 12.2.2. 设备识别
无论是虚拟设备还是物理设备，都通过两个标识符识别：

加密设备API使用唯一的设备索引指定加密设备。
终端消息使用设备名字指定加密设备，用于管理或调试。为了使用方便，端口名字包括端口索引。
### 12.2.3. 设备配置
加密设备的配置包括以下操作：

* 分配资源，对物理设备包括硬件资源。
* 把设备重置到缺省状态。
* 初始化统计计数器。

rte_cryptodev_configure API用于配置加密设备。
```
int rte_cryptodev_configure(uint8_t dev_id,
                            struct rte_cryptodev_config *config)
```
rte_cryptodev_config结构作为配置参数，用于选择socket和队列对的数量。
```
struct rte_cryptodev_config {
    int socket_id;
    /**< Socket to allocate resources on */
    uint16_t nb_queue_pairs;
    /**< Number of queue pairs to configure on device */
};
```
### 12.2.4. 队列对的配置
每个加密设备的队列对都是独立配置的，使用的API是rte_cryptodev_queue_pair_setup。每个队列对的资源可以在指定socket上分配。
```
int rte_cryptodev_queue_pair_setup(uint8_t dev_id, uint16_t queue_pair_id,
            const struct rte_cryptodev_qp_conf *qp_conf,
            int socket_id)

struct rte_cryptodev_qp_conf {
    uint32_t nb_descriptors; /**< Number of descriptors per queue pair */
};
```
### 12.2.5. 逻辑核，内存和队列对的关系
加密设备库也是轮询模式驱动库，在处理器的逻辑核和接口使用本地内存的时候支持NUMA。所以对于对称加密操作，会话和使用的mbuf应该从本地内存的内存池分配。内存缓冲应该留在本地处理器，获取最佳性能，内存缓冲描述符应该使用从本地内存分配的内存池的mbuf填充。

run-to-completion模型的性能也更好，特别是虚拟加密设备，如果加密操作，会话和数据缓冲是在本地内存，而不是远端内存。对于流水线模型，所有逻辑核都在相同处理器时，性能也更好。

多个逻辑核不能使用一个加密设备的相同队列对进行入队和出队操作，因为这样需要全局锁，从而降低性能。而使用不同的逻辑核在一个队列对上执行入队和出队操作是允许的。这说明在报文处理流水线中，突发加密入队/出队API是从一个逻辑核到另一个逻辑核传递的逻辑位置。

## 12.3. 设备功能和能力
加密设备通过两种机制定义功能，全局设备功能和算法能力。全局设备功能识别全设备级的功能，例如设备支持硬件加速或者对称加密操作。

能力机制定义了设备支持的独立算法，例如特定的对称加密，认证操作或者使用关联数据（AEAD）的认证加密操作。

### 12.3.1. 设备功能
目前定义了以下的加密设备功能：

* 对称加密操作
* 非对称加密操作
* 对称加密操作链
* SSE加速的SIMD矢量操作
* AVX加速的SIMD矢量操作
* AVX2加速的SIMD矢量操作
* AESNI加速的操作
* 硬件负荷卸载处理
### 12.3.2. 设备操作能力
加密能力用于识别加密PMD支持的算法，包括操作类型，操作转换，转换识别符和转换细节。加密能力的完整结构定义在DPDK API参考。
```
struct rte_cryptodev_capabilities;
```
每个加密轮询模式驱动定义了自己的私有能力数组，表示这个驱动支持的操作。下面的例子表示一个PMD支持SHA1_HMAC认证算法和AES_CBC加密算法。
```
static const struct rte_cryptodev_capabilities pmd_capabilities[] = {
    {    /* SHA1 HMAC */
        .op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
        .sym = {
            .xform_type = RTE_CRYPTO_SYM_XFORM_AUTH,
            .auth = {
                .algo = RTE_CRYPTO_AUTH_SHA1_HMAC,
                .block_size = 64,
                .key_size = {
                    .min = 64,
                    .max = 64,
                    .increment = 0
                },
                .digest_size = {
                    .min = 12,
                    .max = 12,
                    .increment = 0
                },
                .aad_size = { 0 },
                .iv_size = { 0 }
            }
        }
    },
    {    /* AES CBC */
        .op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
        .sym = {
            .xform_type = RTE_CRYPTO_SYM_XFORM_CIPHER,
            .cipher = {
                .algo = RTE_CRYPTO_CIPHER_AES_CBC,
                .block_size = 16,
                .key_size = {
                    .min = 16,
                    .max = 32,
                    .increment = 8
                },
                .iv_size = {
                    .min = 16,
                    .max = 16,
                    .increment = 0
                }
            }
        }
    }
}
```
### 12.3.3. 能力发现
使用rte_cryptodev_info_get函数获取一个加密设备轮询模式驱动的功能和能力。
```
void rte_cryptodev_info_get(uint8_t dev_id,
                            struct rte_cryptodev_info *dev_info);
```
允许用户查询一个指定的加密PMD，获取这个设备的全部功能和能力。rte_cryptodev_info结构包含了这个设备的全部相关信息。
```
struct rte_cryptodev_info {
    const char *driver_name;
    uint8_t driver_id;
    struct rte_pci_device *pci_dev;

    uint64_t feature_flags;

    const struct rte_cryptodev_capabilities *capabilities;

    unsigned max_nb_queue_pairs;

    struct {
        unsigned max_nb_sessions;
    } sym;
};
```
## 12.4. 操作处理
在DPDK应用的数据路径，加密操作的调度是通过基于批量的异步API执行的。加密设备的队列对使用批量入队API，接受批量的加密操作。在物理加密设备上，批量入队API会把操作放到设备的硬件输入队列，对于虚拟设备，加密设备的入队调用通常完成了加密操作的处理。批量出队API会从加密设备的队列对读取完成的操作，对于物理设备，通常直接从设备的处理队列读取，对于虚拟设备，从rte_ring读取，在入队调用后会把完成的操作放到rte_ring。

### 12.4.1. 批量入队和出队API
批量入队API使用了加密设备标识符和队列对标识符，指定使用的加密设备队列对。nb_ops参数是需要处理的操作数量，具体操作使用rte_crypto_op结构放在ops数组。入队函数返回实际入队列的操作数量，返回值等于nb_ops表示所有报文都入队列了。
```
uint16_t rte_cryptodev_enqueue_burst(uint8_t dev_id, uint16_t qp_id,
                                     struct rte_crypto_op **ops, uint16_t nb_ops)
```
出队API和入队API使用同样的格式，但是nb_ops和ops用来指定用户希望读取的最大操作数和保存操作的位置。API调用返回处理操作的实际数量，不会大于nb_ops。
```
uint16_t rte_cryptodev_dequeue_burst(uint8_t dev_id, uint16_t qp_id,
                                     struct rte_crypto_op **ops, uint16_t nb_ops)
```
### 12.4.2. 操作表示
使用rte_crypto_op结构表示一个加密操作，这个结构是通用的metadata容器，包括了加密设备轮询模式驱动处理加密操作的全部必要信息。

![Fig. 12.1](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/crypto_op.svg)

操作结构包括了操作类型，操作状态和会话类型（基于会话/无会话），指向操作特定数据的引用，操作特定数据的大小和内容由具体操作决定。如果操作是从内存池分配，还包括操作的源内存池。

如果加密操作是从加密操作的内存池分配的，参考下一节，仍然有能力为应用分配操作的私有内存。

应用软件负责为rte_crypto_op结构设置操作指定的字段，加密PMD使用这个结构处理请求的操作。

### 12.4.3. 操作管理和分配
加密设备库提供了API集合，用于管理使用内存池库分配操作内存的加密操作。所以，保证加密操作均匀的分布到内存通道和内存列，优化处理性能。rte_crypto_op有一个字段表明分配的内存池。当调用rte_crypto_op_free(op)时，操作返回到最初的内存池。
```
extern struct rte_mempool *
rte_crypto_op_pool_create(const char *name, enum rte_crypto_op_type type,
                          unsigned nb_elts, unsigned cache_size, uint16_t priv_size,
                          int socket_id);
```
在创建内存池时调用rte_crypto_op_init()，初始化每个加密操作，然后调用__rte_crypto_op_reset()基于类型参数配置操作类型相关的字段。

rte_crypto_op_alloc()和rte_crypto_op_bulk_alloc()用来从指定的加密操作内存池分配指定类型的加密操作。对每个操作调用__rte_crypto_op_reset()，保证应用使用操作时这个操作处于良好的已知状态。
```
struct rte_crypto_op *rte_crypto_op_alloc(struct rte_mempool *mempool,
                                          enum rte_crypto_op_type type)

unsigned rte_crypto_op_bulk_alloc(struct rte_mempool *mempool,
                                  enum rte_crypto_op_type type,
                                  struct rte_crypto_op **ops, uint16_t nb_ops)
```
应用调用rte_crypto_op_free()，把操作返回到分配的内存池。
```
void rte_crypto_op_free(struct rte_crypto_op *op)
```
## 12.5. 对称加密的支持
The cryptodev library currently provides support for the following symmetric Crypto operations; cipher, authentication, including chaining of these operations, as well as also supporting AEAD operations.

### 12.5.1. Session and Session Management
Sessions are used in symmetric cryptographic processing to store the immutable data defined in a cryptographic transform which is used in the operation processing of a packet flow. Sessions are used to manage information such as expand cipher keys and HMAC IPADs and OPADs, which need to be calculated for a particular Crypto operation, but are immutable on a packet to packet basis for a flow. Crypto sessions cache this immutable data in a optimal way for the underlying PMD and this allows further acceleration of the offload of Crypto workloads.

![Fig. 12.2](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/cryptodev_sym_sess.svg)

The Crypto device framework provides APIs to allocate and initizalize sessions for crypto devices, where sessions are mempool objects. It is the application’s responsibility to create and manage the session mempools. This approach allows for different scenarios such as having a single session mempool for all crypto devices (where the mempool object size is big enough to hold the private session of any crypto device), as well as having multiple session mempools of different sizes for better memory usage.

An application can use rte_cryptodev_get_private_session_size() to get the private session size of given crypto device. This function would allow an application to calculate the max device session size of all crypto devices to create a single session mempool. If instead an application creates multiple session mempools, the Crypto device framework also provides rte_cryptodev_get_header_session_size to get the size of an uninitialized session.

Once the session mempools have been created, rte_cryptodev_sym_session_create() is used to allocate an uninitialized session from the given mempool. The session then must be initialized using rte_cryptodev_sym_session_init() for each of the required crypto devices. A symmetric transform chain is used to specify the operation and its parameters. See the section below for details on transforms.

When a session is no longer used, user must call rte_cryptodev_sym_session_clear() for each of the crypto devices that are using the session, to free all driver private session data. Once this is done, session should be freed using rte_cryptodev_sym_session_free which returns them to their mempool.

### 12.5.2. Transforms and Transform Chaining
Symmetric Crypto transforms (rte_crypto_sym_xform) are the mechanism used to specify the details of the Crypto operation. For chaining of symmetric operations such as cipher encrypt and authentication generate, the next pointer allows transform to be chained together. Crypto devices which support chaining must publish the chaining of symmetric Crypto operations feature flag.

Currently there are three transforms types cipher, authentication and AEAD. Also it is important to note that the order in which the transforms are passed indicates the order of the chaining.
```
struct rte_crypto_sym_xform {
    struct rte_crypto_sym_xform *next;
    /**< next xform in chain */
    enum rte_crypto_sym_xform_type type;
    /**< xform type */
    union {
        struct rte_crypto_auth_xform auth;
        /**< Authentication / hash xform */
        struct rte_crypto_cipher_xform cipher;
        /**< Cipher xform */
        struct rte_crypto_aead_xform aead;
        /**< AEAD xform */
    };
};
```
The API does not place a limit on the number of transforms that can be chained together but this will be limited by the underlying Crypto device poll mode driver which is processing the operation.

![Fig. 12.3](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/crypto_xform_chain.svg)

### 12.5.3. Symmetric Operations
The symmetric Crypto operation structure contains all the mutable data relating to performing symmetric cryptographic processing on a referenced mbuf data buffer. It is used for either cipher, authentication, AEAD and chained operations.

As a minimum the symmetric operation must have a source data buffer (m_src), a valid session (or transform chain if in session-less mode) and the minimum authentication/ cipher/ AEAD parameters required depending on the type of operation specified in the session or the transform chain.
```
struct rte_crypto_sym_op {
    struct rte_mbuf *m_src;
    struct rte_mbuf *m_dst;

    union {
        struct rte_cryptodev_sym_session *session;
        /**< Handle for the initialised session context */
        struct rte_crypto_sym_xform *xform;
        /**< Session-less API Crypto operation parameters */
    };

    union {
        struct {
            struct {
                uint32_t offset;
                uint32_t length;
            } data; /**< Data offsets and length for AEAD */

            struct {
                uint8_t *data;
                rte_iova_t phys_addr;
            } digest; /**< Digest parameters */

            struct {
                uint8_t *data;
                rte_iova_t phys_addr;
            } aad;
            /**< Additional authentication parameters */
        } aead;

        struct {
            struct {
                struct {
                    uint32_t offset;
                    uint32_t length;
                } data; /**< Data offsets and length for ciphering */
            } cipher;

            struct {
                struct {
                    uint32_t offset;
                    uint32_t length;
                } data;
                /**< Data offsets and length for authentication */

                struct {
                    uint8_t *data;
                    rte_iova_t phys_addr;
                } digest; /**< Digest parameters */
            } auth;
        };
    };
};
```
## 12.6. Sample code
There are various sample applications that show how to use the cryptodev library, such as the L2fwd with Crypto sample application (L2fwd-crypto) and the IPSec Security Gateway application (ipsec-secgw).

While these applications demonstrate how an application can be created to perform generic crypto operation, the required complexity hides the basic steps of how to use the cryptodev APIs.

The following sample code shows the basic steps to encrypt several buffers with AES-CBC (although performing other crypto operations is similar), using one of the crypto PMDs available in DPDK.
```
/*
 * Simple example to encrypt several buffers with AES-CBC using
 * the Cryptodev APIs.
 */

#define MAX_SESSIONS         1024
#define NUM_MBUFS            1024
#define POOL_CACHE_SIZE      128
#define BURST_SIZE           32
#define BUFFER_SIZE          1024
#define AES_CBC_IV_LENGTH    16
#define AES_CBC_KEY_LENGTH   16
#define IV_OFFSET            (sizeof(struct rte_crypto_op) + \
                             sizeof(struct rte_crypto_sym_op))

struct rte_mempool *mbuf_pool, *crypto_op_pool, *session_pool;
unsigned int session_size;
int ret;

/* Initialize EAL. */
ret = rte_eal_init(argc, argv);
if (ret < 0)
    rte_exit(EXIT_FAILURE, "Invalid EAL arguments\n");

uint8_t socket_id = rte_socket_id();

/* Create the mbuf pool. */
mbuf_pool = rte_pktmbuf_pool_create("mbuf_pool",
                                NUM_MBUFS,
                                POOL_CACHE_SIZE,
                                0,
                                RTE_MBUF_DEFAULT_BUF_SIZE,
                                socket_id);
if (mbuf_pool == NULL)
    rte_exit(EXIT_FAILURE, "Cannot create mbuf pool\n");

/*
 * The IV is always placed after the crypto operation,
 * so some private data is required to be reserved.
 */
unsigned int crypto_op_private_data = AES_CBC_IV_LENGTH;

/* Create crypto operation pool. */
crypto_op_pool = rte_crypto_op_pool_create("crypto_op_pool",
                                        RTE_CRYPTO_OP_TYPE_SYMMETRIC,
                                        NUM_MBUFS,
                                        POOL_CACHE_SIZE,
                                        crypto_op_private_data,
                                        socket_id);
if (crypto_op_pool == NULL)
    rte_exit(EXIT_FAILURE, "Cannot create crypto op pool\n");

/* Create the virtual crypto device. */
char args[128];
const char *crypto_name = "crypto_aesni_mb0";
snprintf(args, sizeof(args), "socket_id=%d", socket_id);
ret = rte_vdev_init(crypto_name, args);
if (ret != 0)
    rte_exit(EXIT_FAILURE, "Cannot create virtual device");

uint8_t cdev_id = rte_cryptodev_get_dev_id(crypto_name);

/* Get private session data size. */
session_size = rte_cryptodev_get_private_session_size(cdev_id);

/*
 * Create session mempool, with two objects per session,
 * one for the session header and another one for the
 * private session data for the crypto device.
 */
session_pool = rte_mempool_create("session_pool",
                                MAX_SESSIONS * 2,
                                session_size,
                                POOL_CACHE_SIZE,
                                0, NULL, NULL, NULL,
                                NULL, socket_id,
                                0);

/* Configure the crypto device. */
struct rte_cryptodev_config conf = {
    .nb_queue_pairs = 1,
    .socket_id = socket_id
};
struct rte_cryptodev_qp_conf qp_conf = {
    .nb_descriptors = 2048
};

if (rte_cryptodev_configure(cdev_id, &conf) < 0)
    rte_exit(EXIT_FAILURE, "Failed to configure cryptodev %u", cdev_id);

if (rte_cryptodev_queue_pair_setup(cdev_id, 0, &qp_conf,
                        socket_id, session_pool) < 0)
    rte_exit(EXIT_FAILURE, "Failed to setup queue pair\n");

if (rte_cryptodev_start(cdev_id) < 0)
    rte_exit(EXIT_FAILURE, "Failed to start device\n");

/* Create the crypto transform. */
uint8_t cipher_key[16] = {0};
struct rte_crypto_sym_xform cipher_xform = {
    .next = NULL,
    .type = RTE_CRYPTO_SYM_XFORM_CIPHER,
    .cipher = {
        .op = RTE_CRYPTO_CIPHER_OP_ENCRYPT,
        .algo = RTE_CRYPTO_CIPHER_AES_CBC,
        .key = {
            .data = cipher_key,
            .length = AES_CBC_KEY_LENGTH
        },
        .iv = {
            .offset = IV_OFFSET,
            .length = AES_CBC_IV_LENGTH
        }
    }
};

/* Create crypto session and initialize it for the crypto device. */
struct rte_cryptodev_sym_session *session;
session = rte_cryptodev_sym_session_create(session_pool);
if (session == NULL)
    rte_exit(EXIT_FAILURE, "Session could not be created\n");

if (rte_cryptodev_sym_session_init(cdev_id, session,
                &cipher_xform, session_pool) < 0)
    rte_exit(EXIT_FAILURE, "Session could not be initialized "
                "for the crypto device\n");

/* Get a burst of crypto operations. */
struct rte_crypto_op *crypto_ops[BURST_SIZE];
if (rte_crypto_op_bulk_alloc(crypto_op_pool,
                        RTE_CRYPTO_OP_TYPE_SYMMETRIC,
                        crypto_ops, BURST_SIZE) == 0)
    rte_exit(EXIT_FAILURE, "Not enough crypto operations available\n");

/* Get a burst of mbufs. */
struct rte_mbuf *mbufs[BURST_SIZE];
if (rte_pktmbuf_alloc_bulk(mbuf_pool, mbufs, BURST_SIZE) < 0)
    rte_exit(EXIT_FAILURE, "Not enough mbufs available");

/* Initialize the mbufs and append them to the crypto operations. */
unsigned int i;
for (i = 0; i < BURST_SIZE; i++) {
    if (rte_pktmbuf_append(mbufs[i], BUFFER_SIZE) == NULL)
        rte_exit(EXIT_FAILURE, "Not enough room in the mbuf\n");
    crypto_ops[i]->sym->m_src = mbufs[i];
}

/* Set up the crypto operations. */
for (i = 0; i < BURST_SIZE; i++) {
    struct rte_crypto_op *op = crypto_ops[i];
    /* Modify bytes of the IV at the end of the crypto operation */
    uint8_t *iv_ptr = rte_crypto_op_ctod_offset(op, uint8_t *,
                                            IV_OFFSET);

    generate_random_bytes(iv_ptr, AES_CBC_IV_LENGTH);

    op->sym->cipher.data.offset = 0;
    op->sym->cipher.data.length = BUFFER_SIZE;

    /* Attach the crypto session to the operation */
    rte_crypto_op_attach_sym_session(op, session);
}

/* Enqueue the crypto operations in the crypto device. */
uint16_t num_enqueued_ops = rte_cryptodev_enqueue_burst(cdev_id, 0,
                                        crypto_ops, BURST_SIZE);

/*
 * Dequeue the crypto operations until all the operations
 * are proccessed in the crypto device.
 */
uint16_t num_dequeued_ops, total_num_dequeued_ops = 0;
do {
    struct rte_crypto_op *dequeued_ops[BURST_SIZE];
    num_dequeued_ops = rte_cryptodev_dequeue_burst(cdev_id, 0,
                                    dequeued_ops, BURST_SIZE);
    total_num_dequeued_ops += num_dequeued_ops;

    /* Check if operation was processed successfully */
    for (i = 0; i < num_dequeued_ops; i++) {
        if (dequeued_ops[i]->status != RTE_CRYPTO_OP_STATUS_SUCCESS)
            rte_exit(EXIT_FAILURE,
                    "Some operations were not processed correctly");
    }

    rte_mempool_put_bulk(crypto_op_pool, (void **)dequeued_ops,
                                        num_dequeued_ops);
} while (total_num_dequeued_ops < num_enqueued_ops);
```
## 12.7. 非对称加密
加密设备API目前不支持非对称加密。

### 12.7.1. 加密设备API
DPDK API参考文档描述了加密设备库的API。
