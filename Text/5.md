
# 5. Ring库
ring提供队列管理。没有使用无限大小的链表，rte_ring有以下属性：

* FIFO
* 最大大小是固定的，指针保存在表中
* 无锁的实现
* 多消费者或单消费者出队列
* 多生产者或单生产者入队列
* 批量出队列，如果成功，将指定数量的对象出队列，否则失败。
* 批量入队列，如果成功，将指定数量的对象入队列，否则失败。
* 突发出队列，如果不能满足指定数量，将尽可能多的对象出队列。
* 突发入队列，如果不能满足指定数量，将尽可能多的对象入队列。

这个数据结构相对于链表的优点如下：

* 速度更快；只需要一条sizeof(void *)的Compare-And-Swap指令，而不是多条double-Compare-And-Swap指令。
* 比完整的无锁队列简单
* 适合批量入队操作和批量出队操作。由于指针保存在表里，将多个对象出队列不会产生链表那么多的cache miss。此外，多个对象的批量出队列的成本不必单个对象的出队列高。

缺点：

* 大小固定
* ring和链表相比，使用了更多内存。一个空ring包括至少N个指针。

这里展示了一个ring的简化表示，使用消费者和生产者的头指针和尾指针指向数据结构中保存的对象。

![Fig. 5.2 Ring Structure](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring1.svg)

## 5.1. References for Ring Implementation in FreeBSD*
The following code was added in FreeBSD 8.0, and is used in some network device drivers (at least in Intel drivers):

* [bufring.h in FreeBSD](http://svn.freebsd.org/viewvc/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;view=markup)
* [bufring.c in FreeBSD](http://svn.freebsd.org/viewvc/base/release/8.0.0/sys/kern/subr_bufring.c?revision=199625&amp;view=markup)
## 5.2. Lockless Ring Buffer in Linux*
The following is a link describing the [Linux Lockless Ring Buffer Design](http://lwn.net/Articles/340400/).

## 5.3. Additional Features
### 5.3.1. Name
A ring is identified by a unique name. It is not possible to create two rings with the same name (rte_ring_create() returns NULL if this is attempted).

## 5.4. Use Cases
Use cases for the Ring library include:

* Communication between applications in the DPDK
* Used by memory pool allocator
## 5.5. Anatomy of a Ring Buffer
This section explains how a ring buffer operates. The ring structure is composed of two head and tail couples; one is used by producers and one is used by the consumers. The figures of the following sections refer to them as prod_head, prod_tail, cons_head and cons_tail.

Each figure represents a simplified state of the ring, which is a circular buffer. The content of the function local variables is represented on the top of the figure, and the content of ring structure is represented on the bottom of the figure.

### 5.5.1. Single Producer Enqueue
This section explains what occurs when a producer adds an object to the ring. In this example, only the producer head and tail (prod_head and prod_tail) are modified, and there is only one producer.

The initial state is to have a prod_head and prod_tail pointing at the same location.

#### 5.5.1.1. Enqueue First Step
First, ring->prod_head and ring->cons_tail are copied in local variables. The prod_next local variable points to the next element of the table, or several elements after in case of bulk enqueue.

If there is not enough room in the ring (this is detected by checking cons_tail), it returns an error.

![Fig. 5.3 Enqueue first step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-enqueue1.svg)

#### 5.5.1.2. Enqueue Second Step
The second step is to modify ring->prod_head in ring structure to point to the same location as prod_next.

A pointer to the added object is copied in the ring (obj4).

![Fig. 5.4 Enqueue second step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-enqueue2.svg)

#### 5.5.1.3. Enqueue Last Step
Once the object is added in the ring, ring->prod_tail in the ring structure is modified to point to the same location as ring->prod_head. The enqueue operation is finished.

![Fig. 5.5 Enqueue last step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-enqueue3.svg)

### 5.5.2. Single Consumer Dequeue
This section explains what occurs when a consumer dequeues an object from the ring. In this example, only the consumer head and tail (cons_head and cons_tail) are modified and there is only one consumer.

The initial state is to have a cons_head and cons_tail pointing at the same location.

#### 5.5.2.1. Dequeue First Step
First, ring->cons_head and ring->prod_tail are copied in local variables. The cons_next local variable points to the next element of the table, or several elements after in the case of bulk dequeue.

If there are not enough objects in the ring (this is detected by checking prod_tail), it returns an error.

![Fig. 5.6 Dequeue last step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-dequeue1.svg)

#### 5.5.2.2. Dequeue Second Step
The second step is to modify ring->cons_head in the ring structure to point to the same location as cons_next.

The pointer to the dequeued object (obj1) is copied in the pointer given by the user.

![Fig. 5.7 Dequeue second step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-dequeue2.svg)

#### 5.5.2.3. Dequeue Last Step
Finally, ring->cons_tail in the ring structure is modified to point to the same location as ring->cons_head. The dequeue operation is finished.

![Fig. 5.8 Dequeue last step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-dequeue3.svg)

### 5.5.3. Multiple Producers Enqueue
This section explains what occurs when two producers concurrently add an object to the ring. In this example, only the producer head and tail (prod_head and prod_tail) are modified.

The initial state is to have a prod_head and prod_tail pointing at the same location.

#### 5.5.3.1. Multiple Producers Enqueue First Step
On both cores, ring->prod_head and ring->cons_tail are copied in local variables. The prod_next local variable points to the next element of the table, or several elements after in the case of bulk enqueue.

If there is not enough room in the ring (this is detected by checking cons_tail), it returns an error.

![Fig. 5.9 Multiple producer enqueue first step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-mp-enqueue1.svg)

#### 5.5.3.2. Multiple Producers Enqueue Second Step
The second step is to modify ring->prod_head in the ring structure to point to the same location as prod_next. This operation is done using a Compare And Swap (CAS) instruction, which does the following operations atomically:

* If ring->prod_head is different to local variable prod_head, the CAS operation fails, and the code restarts at first step.
* Otherwise, ring->prod_head is set to local prod_next, the CAS operation is successful, and processing continues.
In the figure, the operation succeeded on core 1, and step one restarted on core 2.

![Fig. 5.10 Multiple producer enqueue second step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-mp-enqueue2.svg)

#### 5.5.3.3. Multiple Producers Enqueue Third Step
The CAS operation is retried on core 2 with success.

The core 1 updates one element of the ring(obj4), and the core 2 updates another one (obj5).

![Fig. 5.11 Multiple producer enqueue third step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-mp-enqueue3.svg)

#### 5.5.3.4. Multiple Producers Enqueue Fourth Step
Each core now wants to update ring->prod_tail. A core can only update it if ring->prod_tail is equal to the prod_head local variable. This is only true on core 1. The operation is finished on core 1.

![Fig. 5.12 Multiple producer enqueue fourth step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-mp-enqueue4.svg)

#### 5.5.3.5. Multiple Producers Enqueue Last Step
Once ring->prod_tail is updated by core 1, core 2 is allowed to update it too. The operation is also finished on core 2.

![Fig. 5.13 Multiple producer enqueue last step](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-mp-enqueue5.svg)

### 5.5.4. Modulo 32-bit Indexes
In the preceding figures, the prod_head, prod_tail, cons_head and cons_tail indexes are represented by arrows. In the actual implementation, these values are not between 0 and size(ring)-1 as would be assumed. The indexes are between 0 and 2^32 -1, and we mask their value when we access the pointer table (the ring itself). 32-bit modulo also implies that operations on indexes (such as, add/subtract) will automatically do 2^32 modulo if the result overflows the 32-bit number range.

The following are two examples that help to explain how indexes are used in a ring.

| 注意|
| :---|
|To simplify the explanation, operations with modulo 16-bit are used instead of modulo 32-bit. In addition, the four indexes are defined as unsigned 16-bit integers, as opposed to unsigned 32-bit integers in the more realistic case.|

![Fig. 5.14 Modulo 32-bit indexes - Example 1](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-modulo1.svg)

This ring contains 11000 entries.

![Fig. 5.15 Modulo 32-bit indexes - Example 2](https://github.com/gogodick/dpdk_prog_guide/blob/master/Image/ring-modulo2.svg)

This ring contains 12536 entries.

| 注意|
| :---|
|For ease of understanding, we use modulo 65536 operations in the above examples. In real execution cases, this is redundant for low efficiency, but is done automatically when the result overflows.|

The code always maintains a distance between producer and consumer between 0 and size(ring)-1. Thanks to this property, we can do subtractions between 2 index values in a modulo-32bit base: that’s why the overflow of the indexes is not a problem.

At any time, entries and free_entries are between 0 and size(ring)-1, even if only the first term of subtraction has overflowed:

```
uint32_t entries = (prod_tail - cons_head);
uint32_t free_entries = (mask + cons_tail -prod_head);
```
## 5.6. References
[bufring.h in FreeBSD](http://svn.freebsd.org/viewvc/base/release/8.0.0/sys/sys/buf_ring.h?revision=199625&amp;view=markup)(version 8)  
[bufring.c in FreeBSD](http://svn.freebsd.org/viewvc/base/release/8.0.0/sys/kern/subr_bufring.c?revision=199625&amp;view=markup)(version 8)  
[Linux Lockless Ring Buffer Design](http://lwn.net/Articles/340400/)
