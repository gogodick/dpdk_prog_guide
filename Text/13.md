# 13. 安全库
安全库提供了管理和配置安全协议操作的框架，把安全协议操作的负荷卸载到硬件设备。安全库定义了通用API，用于创建和释放安全会话，可以支持全协议的负荷卸载，也可以支持在线加密操作，可以使用网卡或者加密设备。这个框架现在只支持IPSec协议和相关操作，未来会增加其他协议。

## 13.1. 设计原则
安全库为已有的加密设备和以太网设备提供额外的负荷卸载能力。
```
       +---------------+
       | rte_security  |
       +---------------+
         \            /
+-----------+    +--------------+
|  NIC PMD  |    |  CRYPTO PMD  |
+-----------+    +--------------+
```
|注意|
|:---|
|目前，安全库不支持多进程。后续版本会支持这个功能。|

下一节解释了支持的负荷卸载类型。
### 13.1.1. 在线加密
RTE_SECURITY_ACTION_TYPE_INLINE_CRYPTO：在网卡端口接收和发送时，在线进行安全协议（例如IPSec）的加密处理。应该在端口配置基于流的安全动作。

入向数据路径 - 在RX路径进行报文解密，在RX描述符设置相关的加密状态。在线加密处理完成后，主机可以看到一个正常的RX报文，但是报文还是连接了所有安全协议相关的报文头。例如，对于IPSec，报文还有IPSec的隧道头和ESP/AH头，但是收到的报文包括解密数据，而报文到达时这里是加密数据。驱动在RX路径检查描述符，基于加密状态设置rte_mbuf.ol_flags字段。

|注意|
|:---|
|底层设备可能不支持匹配特定流的入向报文加密（例如分片报文），这样的报文还是加密的报文。应用应该负责使用其他加密驱动处理这样的加密报文。|

出向数据路径 - 软件为出向报文添加相关的安全协议头。软件不会对数据加密。驱动会配置TX描述符。硬件设备会加密数据，然后发出报文。

|注意|
|:---|
|底层设备可能支持后加密TSO。|

```
  Egress Data Path
         |
+--------|--------+
|  egress IPsec   |
|        |        |
| +------V------+ |
| | SADB lookup | |
| +------|------+ |
| +------V------+ |
| |   Tunnel    | |   <------ Add tunnel header to packet
| +------|------+ |
| +------V------+ |
| |     ESP     | |   <------ Add ESP header without trailer to packet
| |             | |   <------ Mark packet to be offloaded, add trailer
| +------|------+ |            meta-data to mbuf
+--------V--------+
         |
+--------V--------+
|    L2 Stack     |
+--------|--------+
         |
+--------V--------+
|                 |
|     NIC PMD     |   <------ Set hw context for inline crypto offload
|                 |
+--------|--------+
         |
+--------|--------+
|  HW ACCELERATED |   <------ Packet Encryption and
|        NIC      |           Authentication happens inline
|                 |
+-----------------+
```
### 13.1.2. 在线加密负荷卸载
RTE_SECURITY_ACTION_TYPE_INLINE_PROTOCOL：接收和发送时，在线进行安全协议（如IPSec）的加密和协议处理。应该在端口上配置基于流的安全动作。

入向数据路径 - 在RX路径解密报文，在RX描述符设置相关的加密状态。在线加密处理完成后，主机可以看到一个正常的RX报文，但是可以删除所有安全协议相关的报文头。比如，对于IPSec，报文删除了IPSec隧道头（如果有）和ESP/AH头，收到的报文只包括解密的报文。驱动在RX路径检查描述符，基于加密状态设置rte_mbuf.ol_flags字段。

|注意|
|:---|
|底层设备在这种情况下是有状态的。设备应该支持对匹配指定流的全部报文进行加密处理，包括分片报文（后重组）。比如，对于IPSec，设备应该在内部管理防止重放 等等。设备应该提供防止重放的配置选项，比如丢弃报文，或者设置描述符的错误标志再发给驱动。|

出向数据路径 - 软件会发送明文报文，不添加任何安全协议头。驱动会在TX描述符配置安全索引和其他需要的参数。硬件会对报文进行安全处理，包括添加相关的协议头和加密数据，再发出报文。软件应该保证有足够的内存缓冲，用于添加协议头。如果最终报文的大小会超过MTU，软件也应该预先进行报文分片。

|注意|
|:---|
|底层设备会管理出向处理需要的状态信息。比如对于IPSec，会给报文添加序列号，但是设备应该预先提示序列号溢出。底层设备可以支持后加密TSO。|

```
Egress Data Path
         |
+--------|--------+
|  egress IPsec   |
|        |        |
| +------V------+ |
| | SADB lookup | |
| +------|------+ |
| +------V------+ |
| |   Desc      | |   <------ Mark packet to be offloaded
| +------|------+ |
+--------V--------+
         |
+--------V--------+
|    L2 Stack     |
+--------|--------+
         |
+--------V--------+
|                 |
|     NIC PMD     |   <------ Set hw context for inline crypto offload
|                 |
+--------|--------+
         |
+--------|--------+
|  HW ACCELERATED |   <------ Add tunnel, ESP header etc header to
|        NIC      |           packet. Packet Encryption and
|                 |           Authentication happens inline.
+-----------------+
```

### 13.1.3. 旁路协议负荷卸载
RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL：使用librte_cryptodev来支持编写IPSec安全关联（SA），作为创建安全会话的一部分，包括定义。除了加密设备定义的标准加密处理，安全协议的处理也卸载到加密设备。

解密：报文发送到加密设备，进行安全协议处理。设备会进行报文解密，并且可选的删除额外的安全头。例如，对于IPSec报文，会删除IPSec隧道头（如果有）和ESP/AH头，解密报文只包括明文数据。

|注意|
|:---|
|对于IPSec，设备可以内部管理防止重放等。设备会提供防止重放行为的配置选项，例如丢弃报文，或者设置描述符的错误标志再发给驱动。|

加密：软件会正常提交报文到加密设备，这种情况下硬件会添加相关的安全协议头，进行报文加密。软件应该保证有足够的内存缓冲用来添加任何协议头。

|注意|
|:---|
|对于IPSec，会给报文添加序列号，应该预先通知序列号溢出。|

```
 Egress Data Path
         |
+--------|--------+
|  egress IPsec   |
|        |        |
| +------V------+ |
| | SADB lookup | |   <------ SA maps to cryptodev session
| +------|------+ |
| +------|------+ |
| |      \--------------------\
| |    Crypto   | |           |  <- Crypto processing through
| |      /----------------\   |     inline crypto PMD
| +------|------+ |       |   |
+--------V--------+       |   |
         |                |   |
+--------V--------+       |   |  create   <-- SA is added to hw
|    L2 Stack     |       |   |  inline       using existing create
+--------|--------+       |   |  session      sym session APIs
         |                |   |    |
+--------V--------+   +---|---|----V---+
|                 |   |   \---/    |   | <--- Add tunnel, ESP header etc
|     NIC PMD     |   |   INLINE   |   |      header to packet.Packet
|                 |   | CRYPTO PMD |   |      Encryption/Decryption and
+--------|--------+   +----------------+      Authentication happens
         |                                    inline.
+--------|--------+
|       NIC       |
+--------|--------+
         V
```

## 13.2. 设备功能和能力
### 13.2.1. 设备的安全操作能力
The device (crypto or ethernet) capabilities which support security operations, are defined by the security action type, security protocol, protocol capabilities and corresponding crypto capabilities for security. For the full scope of the Security capability see definition of rte_security_capability structure in the DPDK API Reference.
```
struct rte_security_capability;
```
Each driver (crypto or ethernet) defines its own private array of capabilities for the operations it supports. Below is an example of the capabilities for a PMD which supports the IPSec protocol.
```
static const struct rte_security_capability pmd_security_capabilities[] = {
    { /* IPsec Lookaside Protocol offload ESP Tunnel Egress */
            .action = RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL,
            .protocol = RTE_SECURITY_PROTOCOL_IPSEC,
            .ipsec = {
                    .proto = RTE_SECURITY_IPSEC_SA_PROTO_ESP,
                    .mode = RTE_SECURITY_IPSEC_SA_MODE_TUNNEL,
                    .direction = RTE_SECURITY_IPSEC_SA_DIR_EGRESS,
                    .options = { 0 }
            },
            .crypto_capabilities = pmd_capabilities
    },
    { /* IPsec Lookaside Protocol offload ESP Tunnel Ingress */
            .action = RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL,
            .protocol = RTE_SECURITY_PROTOCOL_IPSEC,
            .ipsec = {
                    .proto = RTE_SECURITY_IPSEC_SA_PROTO_ESP,
                    .mode = RTE_SECURITY_IPSEC_SA_MODE_TUNNEL,
                    .direction = RTE_SECURITY_IPSEC_SA_DIR_INGRESS,
                    .options = { 0 }
            },
            .crypto_capabilities = pmd_capabilities
    },
    {
            .action = RTE_SECURITY_ACTION_TYPE_NONE
    }
};
static const struct rte_cryptodev_capabilities pmd_capabilities[] = {
    {    /* SHA1 HMAC */
        .op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
        .sym = {
            .xform_type = RTE_CRYPTO_SYM_XFORM_AUTH,
            .auth = {
                .algo = RTE_CRYPTO_AUTH_SHA1_HMAC,
                .block_size = 64,
                .key_size = {
                    .min = 64,
                    .max = 64,
                    .increment = 0
                },
                .digest_size = {
                    .min = 12,
                    .max = 12,
                    .increment = 0
                },
                .aad_size = { 0 },
                .iv_size = { 0 }
            }
        }
    },
    {    /* AES CBC */
        .op = RTE_CRYPTO_OP_TYPE_SYMMETRIC,
        .sym = {
            .xform_type = RTE_CRYPTO_SYM_XFORM_CIPHER,
            .cipher = {
                .algo = RTE_CRYPTO_CIPHER_AES_CBC,
                .block_size = 16,
                .key_size = {
                    .min = 16,
                    .max = 32,
                    .increment = 8
                },
                .iv_size = {
                    .min = 16,
                    .max = 16,
                    .increment = 0
                }
            }
        }
    }
}
```
### 13.2.2. Capabilities Discovery
Discovering the features and capabilities of a driver (crypto/ethernet) is achieved through the rte_security_capabilities_get() function.
```
const struct rte_security_capability *rte_security_capabilities_get(uint16_t id);
```
This allows the user to query a specific driver and get all device security capabilities. It returns an array of rte_security_capability structures which contains all the capabilities for that device.

### 13.2.3. Security Session Create/Free
Security Sessions are created to store the immutable fields of a particular Security Association for a particular protocol which is defined by a security session configuration structure which is used in the operation processing of a packet flow. Sessions are used to manage protocol specific information as well as crypto parameters. Security sessions cache this immutable data in a optimal way for the underlying PMD and this allows further acceleration of the offload of Crypto workloads.

The Security framework provides APIs to create and free sessions for crypto/ethernet devices, where sessions are mempool objects. It is the application’s responsibility to create and manage the session mempools. The mempool object size should be able to accommodate the driver’s private data of security session.

Once the session mempools have been created, rte_security_session_create() is used to allocate and initialize a session for the required crypto/ethernet device.

Session APIs need a parameter rte_security_ctx to identify the crypto/ethernet security ops. This parameter can be retrieved using the APIs rte_cryptodev_get_sec_ctx() (for crypto device) or rte_eth_dev_get_sec_ctx (for ethernet port).

Sessions already created can be updated with rte_security_session_update().

When a session is no longer used, the user must call rte_security_session_destroy() to free the driver private session data and return the memory back to the mempool.

For look aside protocol offload to hardware crypto device, the rte_crypto_op created by the application is attached to the security session by the API rte_security_attach_session().

For Inline Crypto and Inline protocol offload, device specific defined metadata is updated in the mbuf using rte_security_set_pkt_metadata() if DEV_TX_OFFLOAD_SEC_NEED_MDATA is set.
### 13.2.4. Security session configuration
Security Session configuration structure is defined as rte_security_session_conf
```
struct rte_security_session_conf {
    enum rte_security_session_action_type action_type;
    /**< Type of action to be performed on the session */
    enum rte_security_session_protocol protocol;
    /**< Security protocol to be configured */
    union {
            struct rte_security_ipsec_xform ipsec;
            struct rte_security_macsec_xform macsec;
    };
    /**< Configuration parameters for security session */
    struct rte_crypto_sym_xform *crypto_xform;
    /**< Security Session Crypto Transformations */
};
```
The configuration structure reuses the rte_crypto_sym_xform struct for crypto related configuration. The rte_security_session_action_type struct is used to specify whether the session is configured for Lookaside Protocol offload or Inline Crypto or Inline Protocol Offload.
```
enum rte_security_session_action_type {
    RTE_SECURITY_ACTION_TYPE_NONE,
    /**< No security actions */
    RTE_SECURITY_ACTION_TYPE_INLINE_CRYPTO,
    /**< Crypto processing for security protocol is processed inline
     * during transmission */
    RTE_SECURITY_ACTION_TYPE_INLINE_PROTOCOL,
    /**< All security protocol processing is performed inline during
     * transmission */
    RTE_SECURITY_ACTION_TYPE_LOOKASIDE_PROTOCOL
    /**< All security protocol processing including crypto is performed
     * on a lookaside accelerator */
};
```
The rte_security_session_protocol is defined as
```
enum rte_security_session_protocol {
    RTE_SECURITY_PROTOCOL_IPSEC,
    /**< IPsec Protocol */
    RTE_SECURITY_PROTOCOL_MACSEC,
    /**< MACSec Protocol */
};
```
Currently the library defines configuration parameters for IPSec only. For other protocols like MACSec, structures and enums are defined as place holders which will be updated in the future.

IPsec related configuration parameters are defined in rte_security_ipsec_xform
```
struct rte_security_ipsec_xform {
    uint32_t spi;
    /**< SA security parameter index */
    uint32_t salt;
    /**< SA salt */
    struct rte_security_ipsec_sa_options options;
    /**< various SA options */
    enum rte_security_ipsec_sa_direction direction;
    /**< IPSec SA Direction - Egress/Ingress */
    enum rte_security_ipsec_sa_protocol proto;
    /**< IPsec SA Protocol - AH/ESP */
    enum rte_security_ipsec_sa_mode mode;
    /**< IPsec SA Mode - transport/tunnel */
    struct rte_security_ipsec_tunnel_param tunnel;
    /**< Tunnel parameters, NULL for transport mode */
};
```
### 13.2.5. Security API
The rte_security Library API is described in the DPDK API Reference document.

### 13.2.6. Flow based Security Session
In the case of NIC based offloads, the security session specified in the ‘rte_flow_action_security’ must be created on the same port as the flow action that is being specified.

The ingress/egress flow attribute should match that specified in the security session if the security session supports the definition of the direction.

Multiple flows can be configured to use the same security session. For example if the security session specifies an egress IPsec SA, then multiple flows can be specified to that SA. In the case of an ingress IPsec SA then it is only valid to have a single flow to map to that security session.
```
 Configuration Path
         |
+--------|--------+
|    Add/Remove   |
|     IPsec SA    |   <------ Build security flow action of
|        |        |           ipsec transform
|--------|--------|
         |
+--------V--------+
|   Flow API      |
+--------|--------+
         |
+--------V--------+
|                 |
|     NIC PMD     |   <------ Add/Remove SA to/from hw context
|                 |
+--------|--------+
         |
+--------|--------+
|  HW ACCELERATED |
|        NIC      |
|                 |
+--------|--------+
```
* Add/Delete SA flow: To add a new inline SA construct a rte_flow_item for Ethernet + IP + ESP using the SA selectors and the rte_crypto_ipsec_xform as the rte_flow_action. Note that any rte_flow_items may be empty, which means it is not checked.
```
In its most basic form, IPsec flow specification is as follows:
    +-------+     +----------+    +--------+    +-----+
    |  Eth  | ->  |   IP4/6  | -> |   ESP  | -> | END |
    +-------+     +----------+    +--------+    +-----+

However, the API can represent, IPsec crypto offload with any encapsulation:
    +-------+            +--------+    +-----+
    |  Eth  | ->  ... -> |   ESP  | -> | END |
    +-------+            +--------+    +-----+
```
